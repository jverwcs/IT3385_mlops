2025-08-27 19:49:44,939:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-27 19:49:44,939:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-27 19:49:44,939:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-27 19:49:44,939:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-27 19:49:45,949:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\mlflow\protos\service_pb2.py:11: UserWarning: google.protobuf.service module is deprecated. RPC implementations should provide code generator plugins which generate code specific to the RPC implementation. service.py will be removed in Jan 2025
  from google.protobuf import service as _service

2025-08-27 19:49:47,746:INFO:Initializing load_model()
2025-08-27 19:49:47,746:INFO:load_model(model_name=models/wheat_seeds_best, platform=None, authentication=None, verbose=True)
2025-08-27 19:50:28,281:INFO:Initializing predict_model()
2025-08-27 19:50:28,281:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000002045AF39330>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000002045C61D870>)
2025-08-27 19:50:28,281:INFO:Checking exceptions
2025-08-27 19:50:28,281:INFO:Preloading libraries
2025-08-27 19:50:28,281:INFO:Set up data.
2025-08-27 19:50:28,284:INFO:Set up index.
2025-08-27 20:05:11,247:INFO:Initializing predict_model()
2025-08-27 20:05:11,248:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000002045B3D3DC0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x0000020414FDAA70>)
2025-08-27 20:05:11,248:INFO:Checking exceptions
2025-08-27 20:05:11,248:INFO:Preloading libraries
2025-08-27 20:05:11,248:INFO:Set up data.
2025-08-27 20:05:11,250:INFO:Set up index.
2025-08-27 20:05:20,508:INFO:Initializing predict_model()
2025-08-27 20:05:20,509:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000002045C646D10>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x0000020414FDBE20>)
2025-08-27 20:05:20,509:INFO:Checking exceptions
2025-08-27 20:05:20,509:INFO:Preloading libraries
2025-08-27 20:05:20,509:INFO:Set up data.
2025-08-27 20:05:20,511:INFO:Set up index.
2025-08-27 20:17:13,695:INFO:Initializing load_model()
2025-08-27 20:17:13,695:INFO:load_model(model_name=m, platform=None, authentication=None, verbose=True)
2025-08-27 20:17:13,697:INFO:Initializing load_model()
2025-08-27 20:17:13,697:INFO:load_model(model_name=o, platform=None, authentication=None, verbose=True)
2025-08-27 20:17:13,698:INFO:Initializing load_model()
2025-08-27 20:17:13,698:INFO:load_model(model_name=d, platform=None, authentication=None, verbose=True)
2025-08-27 20:17:13,700:INFO:Initializing load_model()
2025-08-27 20:17:13,700:INFO:load_model(model_name=e, platform=None, authentication=None, verbose=True)
2025-08-27 20:17:13,701:INFO:Initializing load_model()
2025-08-27 20:17:13,701:INFO:load_model(model_name=l, platform=None, authentication=None, verbose=True)
2025-08-27 20:17:13,702:INFO:Initializing load_model()
2025-08-27 20:17:13,702:INFO:load_model(model_name=s, platform=None, authentication=None, verbose=True)
2025-08-27 20:17:13,704:INFO:Initializing load_model()
2025-08-27 20:17:13,704:INFO:load_model(model_name=/, platform=None, authentication=None, verbose=True)
2025-08-27 20:17:13,705:INFO:Initializing load_model()
2025-08-27 20:17:13,705:INFO:load_model(model_name=w, platform=None, authentication=None, verbose=True)
2025-08-27 20:17:13,706:INFO:Initializing load_model()
2025-08-27 20:17:13,706:INFO:load_model(model_name=h, platform=None, authentication=None, verbose=True)
2025-08-27 20:17:13,707:INFO:Initializing load_model()
2025-08-27 20:17:13,707:INFO:load_model(model_name=e, platform=None, authentication=None, verbose=True)
2025-08-27 20:17:13,708:INFO:Initializing load_model()
2025-08-27 20:17:13,708:INFO:load_model(model_name=a, platform=None, authentication=None, verbose=True)
2025-08-27 20:17:13,709:INFO:Initializing load_model()
2025-08-27 20:17:13,709:INFO:load_model(model_name=t, platform=None, authentication=None, verbose=True)
2025-08-27 20:17:13,710:INFO:Initializing load_model()
2025-08-27 20:17:13,710:INFO:load_model(model_name=_, platform=None, authentication=None, verbose=True)
2025-08-27 20:17:13,711:INFO:Initializing load_model()
2025-08-27 20:17:13,711:INFO:load_model(model_name=s, platform=None, authentication=None, verbose=True)
2025-08-27 20:17:13,712:INFO:Initializing load_model()
2025-08-27 20:17:13,712:INFO:load_model(model_name=e, platform=None, authentication=None, verbose=True)
2025-08-27 20:17:13,713:INFO:Initializing load_model()
2025-08-27 20:17:13,714:INFO:load_model(model_name=e, platform=None, authentication=None, verbose=True)
2025-08-27 20:17:13,715:INFO:Initializing load_model()
2025-08-27 20:17:13,715:INFO:load_model(model_name=d, platform=None, authentication=None, verbose=True)
2025-08-27 20:17:13,716:INFO:Initializing load_model()
2025-08-27 20:17:13,716:INFO:load_model(model_name=s, platform=None, authentication=None, verbose=True)
2025-08-27 20:17:13,717:INFO:Initializing load_model()
2025-08-27 20:17:13,717:INFO:load_model(model_name=_, platform=None, authentication=None, verbose=True)
2025-08-27 20:17:13,718:INFO:Initializing load_model()
2025-08-27 20:17:13,718:INFO:load_model(model_name=b, platform=None, authentication=None, verbose=True)
2025-08-27 20:17:13,719:INFO:Initializing load_model()
2025-08-27 20:17:13,720:INFO:load_model(model_name=e, platform=None, authentication=None, verbose=True)
2025-08-27 20:17:13,721:INFO:Initializing load_model()
2025-08-27 20:17:13,721:INFO:load_model(model_name=s, platform=None, authentication=None, verbose=True)
2025-08-27 20:17:13,722:INFO:Initializing load_model()
2025-08-27 20:17:13,722:INFO:load_model(model_name=t, platform=None, authentication=None, verbose=True)
2025-08-27 20:20:21,086:INFO:Initializing load_model()
2025-08-27 20:20:21,086:INFO:load_model(model_name=models/wheat_seeds_best, platform=None, authentication=None, verbose=True)
2025-08-27 20:20:21,112:INFO:Initializing predict_model()
2025-08-27 20:20:21,112:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000204152209D0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000002045C61E050>)
2025-08-27 20:20:21,113:INFO:Checking exceptions
2025-08-27 20:20:21,113:INFO:Preloading libraries
2025-08-27 20:20:21,113:INFO:Set up data.
2025-08-27 20:20:21,118:INFO:Set up index.
2025-08-27 20:20:30,274:INFO:Initializing predict_model()
2025-08-27 20:20:30,274:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000002045C644FA0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000002045C61F640>)
2025-08-27 20:20:30,274:INFO:Checking exceptions
2025-08-27 20:20:30,274:INFO:Preloading libraries
2025-08-27 20:20:30,275:INFO:Set up data.
2025-08-27 20:20:30,277:INFO:Set up index.
2025-08-27 20:21:30,821:INFO:Initializing predict_model()
2025-08-27 20:21:30,821:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000002045C5FE7A0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x0000020414FDA9E0>)
2025-08-27 20:21:30,821:INFO:Checking exceptions
2025-08-27 20:21:30,821:INFO:Preloading libraries
2025-08-27 20:21:30,822:INFO:Set up data.
2025-08-27 20:21:30,824:INFO:Set up index.
2025-08-27 20:21:32,412:INFO:Initializing predict_model()
2025-08-27 20:21:32,412:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000002045C647F70>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000002045C61D6C0>)
2025-08-27 20:21:32,412:INFO:Checking exceptions
2025-08-27 20:21:32,412:INFO:Preloading libraries
2025-08-27 20:21:32,412:INFO:Set up data.
2025-08-27 20:21:32,415:INFO:Set up index.
2025-08-27 20:21:36,276:INFO:Initializing predict_model()
2025-08-27 20:21:36,277:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000002045C6445B0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000002045C61CCA0>)
2025-08-27 20:21:36,277:INFO:Checking exceptions
2025-08-27 20:21:36,277:INFO:Preloading libraries
2025-08-27 20:21:36,277:INFO:Set up data.
2025-08-27 20:21:36,281:INFO:Set up index.
2025-08-27 20:21:41,879:INFO:Initializing predict_model()
2025-08-27 20:21:41,879:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000002045C5FFFD0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x0000020414FDA9E0>)
2025-08-27 20:21:41,879:INFO:Checking exceptions
2025-08-27 20:21:41,879:INFO:Preloading libraries
2025-08-27 20:21:41,879:INFO:Set up data.
2025-08-27 20:21:41,882:INFO:Set up index.
2025-08-27 20:21:41,989:INFO:Initializing predict_model()
2025-08-27 20:21:41,989:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000002045C647BE0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000002045C61FD90>)
2025-08-27 20:21:41,989:INFO:Checking exceptions
2025-08-27 20:21:41,989:INFO:Preloading libraries
2025-08-27 20:21:41,990:INFO:Set up data.
2025-08-27 20:21:41,992:INFO:Set up index.
2025-08-27 20:26:28,160:INFO:Initializing predict_model()
2025-08-27 20:26:28,160:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000002045B9145E0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000002045B8E4430>)
2025-08-27 20:26:28,161:INFO:Checking exceptions
2025-08-27 20:26:28,161:INFO:Preloading libraries
2025-08-27 20:26:28,161:INFO:Set up data.
2025-08-27 20:26:28,164:INFO:Set up index.
2025-08-27 20:27:15,012:INFO:Initializing predict_model()
2025-08-27 20:27:15,012:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000002045B3D3F10>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000002045B8E44C0>)
2025-08-27 20:27:15,013:INFO:Checking exceptions
2025-08-27 20:27:15,013:INFO:Preloading libraries
2025-08-27 20:27:15,013:INFO:Set up data.
2025-08-27 20:27:15,016:INFO:Set up index.
2025-08-27 22:25:25,324:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-27 22:25:25,324:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-27 22:25:25,324:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-27 22:25:25,324:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-27 22:25:26,339:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\mlflow\protos\service_pb2.py:11: UserWarning: google.protobuf.service module is deprecated. RPC implementations should provide code generator plugins which generate code specific to the RPC implementation. service.py will be removed in Jan 2025
  from google.protobuf import service as _service

2025-08-27 22:25:28,207:INFO:Initializing load_model()
2025-08-27 22:25:28,208:INFO:load_model(model_name=models/wheat_seeds_best, platform=None, authentication=None, verbose=True)
2025-08-27 22:26:00,910:INFO:Initializing predict_model()
2025-08-27 22:26:00,910:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218E1C295D0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218E1CA6560>)
2025-08-27 22:26:00,910:INFO:Checking exceptions
2025-08-27 22:26:00,910:INFO:Preloading libraries
2025-08-27 22:26:00,910:INFO:Set up data.
2025-08-27 22:26:00,913:INFO:Set up index.
2025-08-27 22:26:19,424:INFO:Initializing predict_model()
2025-08-27 22:26:19,424:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218E1CC1270>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218A893BC70>)
2025-08-27 22:26:19,424:INFO:Checking exceptions
2025-08-27 22:26:19,424:INFO:Preloading libraries
2025-08-27 22:26:19,425:INFO:Set up data.
2025-08-27 22:26:19,427:INFO:Set up index.
2025-08-27 22:27:05,788:INFO:Initializing predict_model()
2025-08-27 22:27:05,788:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218A96CAA10>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218A95E6680>)
2025-08-27 22:27:05,789:INFO:Checking exceptions
2025-08-27 22:27:05,789:INFO:Preloading libraries
2025-08-27 22:27:05,789:INFO:Set up data.
2025-08-27 22:27:05,792:INFO:Set up index.
2025-08-27 22:27:05,941:INFO:Initializing predict_model()
2025-08-27 22:27:05,941:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218A96CB820>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218E1CA6560>)
2025-08-27 22:27:05,941:INFO:Checking exceptions
2025-08-27 22:27:05,941:INFO:Preloading libraries
2025-08-27 22:27:05,942:INFO:Set up data.
2025-08-27 22:27:05,944:INFO:Set up index.
2025-08-27 22:40:43,781:INFO:Initializing predict_model()
2025-08-27 22:40:43,781:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218A984A350>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218E1C14550>)
2025-08-27 22:40:43,781:INFO:Checking exceptions
2025-08-27 22:40:43,781:INFO:Preloading libraries
2025-08-27 22:40:43,782:INFO:Set up data.
2025-08-27 22:40:43,785:INFO:Set up index.
2025-08-27 22:40:56,964:INFO:Initializing predict_model()
2025-08-27 22:40:56,964:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218A96CB430>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218A96AEE60>)
2025-08-27 22:40:56,964:INFO:Checking exceptions
2025-08-27 22:40:56,965:INFO:Preloading libraries
2025-08-27 22:40:56,965:INFO:Set up data.
2025-08-27 22:40:56,967:INFO:Set up index.
2025-08-27 22:41:04,844:INFO:Initializing predict_model()
2025-08-27 22:41:04,844:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218A96CB0D0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218A86811B0>)
2025-08-27 22:41:04,844:INFO:Checking exceptions
2025-08-27 22:41:04,844:INFO:Preloading libraries
2025-08-27 22:41:04,845:INFO:Set up data.
2025-08-27 22:41:04,847:INFO:Set up index.
2025-08-27 22:41:04,973:INFO:Initializing predict_model()
2025-08-27 22:41:04,973:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218E1C8AB00>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218A96AF010>)
2025-08-27 22:41:04,973:INFO:Checking exceptions
2025-08-27 22:41:04,973:INFO:Preloading libraries
2025-08-27 22:41:04,973:INFO:Set up data.
2025-08-27 22:41:04,975:INFO:Set up index.
2025-08-27 22:41:14,964:INFO:Initializing predict_model()
2025-08-27 22:41:14,964:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218E1C299F0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218A95E6710>)
2025-08-27 22:41:14,965:INFO:Checking exceptions
2025-08-27 22:41:14,965:INFO:Preloading libraries
2025-08-27 22:41:14,965:INFO:Set up data.
2025-08-27 22:41:14,967:INFO:Set up index.
2025-08-27 22:41:16,055:INFO:Initializing predict_model()
2025-08-27 22:41:16,055:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218A98499F0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218A86BA4D0>)
2025-08-27 22:41:16,055:INFO:Checking exceptions
2025-08-27 22:41:16,055:INFO:Preloading libraries
2025-08-27 22:41:16,056:INFO:Set up data.
2025-08-27 22:41:16,058:INFO:Set up index.
2025-08-27 22:41:16,179:INFO:Initializing predict_model()
2025-08-27 22:41:16,179:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218A826D7E0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218E1CA4670>)
2025-08-27 22:41:16,179:INFO:Checking exceptions
2025-08-27 22:41:16,179:INFO:Preloading libraries
2025-08-27 22:41:16,180:INFO:Set up data.
2025-08-27 22:41:16,183:INFO:Set up index.
2025-08-27 22:43:18,794:INFO:Initializing predict_model()
2025-08-27 22:43:18,795:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218A96C9B40>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218A86BBD00>)
2025-08-27 22:43:18,795:INFO:Checking exceptions
2025-08-27 22:43:18,795:INFO:Preloading libraries
2025-08-27 22:43:18,796:INFO:Set up data.
2025-08-27 22:43:18,800:INFO:Set up index.
2025-08-27 22:44:45,091:INFO:Initializing predict_model()
2025-08-27 22:44:45,091:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218E1C8A7A0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218A86B97E0>)
2025-08-27 22:44:45,091:INFO:Checking exceptions
2025-08-27 22:44:45,091:INFO:Preloading libraries
2025-08-27 22:44:45,092:INFO:Set up data.
2025-08-27 22:44:45,094:INFO:Set up index.
2025-08-27 22:44:45,793:INFO:Initializing predict_model()
2025-08-27 22:44:45,793:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218A96C98A0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218A86B9EA0>)
2025-08-27 22:44:45,794:INFO:Checking exceptions
2025-08-27 22:44:45,794:INFO:Preloading libraries
2025-08-27 22:44:45,794:INFO:Set up data.
2025-08-27 22:44:45,798:INFO:Set up index.
2025-08-27 22:44:51,611:INFO:Initializing predict_model()
2025-08-27 22:44:51,611:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218A96CBF70>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218E1C16290>)
2025-08-27 22:44:51,611:INFO:Checking exceptions
2025-08-27 22:44:51,611:INFO:Preloading libraries
2025-08-27 22:44:51,612:INFO:Set up data.
2025-08-27 22:44:51,614:INFO:Set up index.
2025-08-27 22:44:54,923:INFO:Initializing predict_model()
2025-08-27 22:44:54,924:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218A96C9BA0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218A914EC20>)
2025-08-27 22:44:54,924:INFO:Checking exceptions
2025-08-27 22:44:54,924:INFO:Preloading libraries
2025-08-27 22:44:54,924:INFO:Set up data.
2025-08-27 22:44:54,929:INFO:Set up index.
2025-08-27 22:44:55,078:INFO:Initializing predict_model()
2025-08-27 22:44:55,079:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218E1C29240>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218A914EC20>)
2025-08-27 22:44:55,079:INFO:Checking exceptions
2025-08-27 22:44:55,079:INFO:Preloading libraries
2025-08-27 22:44:55,080:INFO:Set up data.
2025-08-27 22:44:55,083:INFO:Set up index.
2025-08-27 22:48:50,731:INFO:Initializing predict_model()
2025-08-27 22:48:50,731:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218A985C640>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218E1C15870>)
2025-08-27 22:48:50,731:INFO:Checking exceptions
2025-08-27 22:48:50,731:INFO:Preloading libraries
2025-08-27 22:48:50,732:INFO:Set up data.
2025-08-27 22:48:50,734:INFO:Set up index.
2025-08-27 22:49:11,200:INFO:Initializing predict_model()
2025-08-27 22:49:11,200:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218A985DCF0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218E1C15990>)
2025-08-27 22:49:11,201:INFO:Checking exceptions
2025-08-27 22:49:11,201:INFO:Preloading libraries
2025-08-27 22:49:11,201:INFO:Set up data.
2025-08-27 22:49:11,203:INFO:Set up index.
2025-08-27 23:01:49,254:INFO:Initializing predict_model()
2025-08-27 23:01:49,254:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218E1C8AA40>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218A87FBC70>)
2025-08-27 23:01:49,254:INFO:Checking exceptions
2025-08-27 23:01:49,254:INFO:Preloading libraries
2025-08-27 23:01:49,255:INFO:Set up data.
2025-08-27 23:01:49,257:INFO:Set up index.
2025-08-27 23:02:00,177:INFO:Initializing predict_model()
2025-08-27 23:02:00,177:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218A86088E0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218E1C15BD0>)
2025-08-27 23:02:00,177:INFO:Checking exceptions
2025-08-27 23:02:00,177:INFO:Preloading libraries
2025-08-27 23:02:00,177:INFO:Set up data.
2025-08-27 23:02:00,180:INFO:Set up index.
2025-08-27 23:02:05,600:INFO:Initializing predict_model()
2025-08-27 23:02:05,600:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218A90CE0B0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218E1C15D80>)
2025-08-27 23:02:05,600:INFO:Checking exceptions
2025-08-27 23:02:05,600:INFO:Preloading libraries
2025-08-27 23:02:05,601:INFO:Set up data.
2025-08-27 23:02:05,604:INFO:Set up index.
2025-08-27 23:29:37,854:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-27 23:29:37,854:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-27 23:29:37,854:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-27 23:29:37,854:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-27 23:29:38,387:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\mlflow\protos\service_pb2.py:11: UserWarning: google.protobuf.service module is deprecated. RPC implementations should provide code generator plugins which generate code specific to the RPC implementation. service.py will be removed in Jan 2025
  from google.protobuf import service as _service

2025-08-27 23:31:05,389:INFO:PyCaret ClassificationExperiment
2025-08-27 23:31:05,389:INFO:Logging name: wheat_seeds_cls
2025-08-27 23:31:05,389:INFO:ML Usecase: MLUsecase.CLASSIFICATION
2025-08-27 23:31:05,389:INFO:version 3.3.2
2025-08-27 23:31:05,389:INFO:Initializing setup()
2025-08-27 23:31:05,389:INFO:self.USI: f64b
2025-08-27 23:31:05,389:INFO:self._variable_keys: {'fold_generator', 'data', 'X_test', 'gpu_param', 'exp_id', 'is_multiclass', 'seed', 'n_jobs_param', 'pipeline', 'exp_name_log', 'y', 'fold_shuffle_param', 'html_param', 'X', '_available_plots', 'X_train', 'USI', 'idx', 'memory', 'target_param', '_ml_usecase', 'logging_param', 'fold_groups_param', 'y_train', 'y_test', 'log_plots_param', 'gpu_n_jobs_param', 'fix_imbalance'}
2025-08-27 23:31:05,389:INFO:Checking environment
2025-08-27 23:31:05,389:INFO:python_version: 3.10.18
2025-08-27 23:31:05,389:INFO:python_build: ('main', 'Jun  5 2025 13:08:55')
2025-08-27 23:31:05,389:INFO:machine: AMD64
2025-08-27 23:31:05,389:INFO:platform: Windows-10-10.0.19045-SP0
2025-08-27 23:31:05,401:INFO:Memory: svmem(total=34278952960, available=11606728704, percent=66.1, used=22672224256, free=11606728704)
2025-08-27 23:31:05,402:INFO:Physical Core: 8
2025-08-27 23:31:05,402:INFO:Logical Core: 16
2025-08-27 23:31:05,402:INFO:Checking libraries
2025-08-27 23:31:05,402:INFO:System:
2025-08-27 23:31:05,402:INFO:    python: 3.10.18 | packaged by Anaconda, Inc. | (main, Jun  5 2025, 13:08:55) [MSC v.1929 64 bit (AMD64)]
2025-08-27 23:31:05,402:INFO:executable: C:\Users\javie\anaconda3\envs\mlops\python.exe
2025-08-27 23:31:05,402:INFO:   machine: Windows-10-10.0.19045-SP0
2025-08-27 23:31:05,402:INFO:PyCaret required dependencies:
2025-08-27 23:31:06,323:INFO:                 pip: 25.1
2025-08-27 23:31:06,323:INFO:          setuptools: 78.1.1
2025-08-27 23:31:06,323:INFO:             pycaret: 3.3.2
2025-08-27 23:31:06,323:INFO:             IPython: 8.37.0
2025-08-27 23:31:06,323:INFO:          ipywidgets: 8.1.7
2025-08-27 23:31:06,323:INFO:                tqdm: 4.67.1
2025-08-27 23:31:06,324:INFO:               numpy: 1.26.4
2025-08-27 23:31:06,324:INFO:              pandas: 2.1.4
2025-08-27 23:31:06,324:INFO:              jinja2: 3.1.6
2025-08-27 23:31:06,324:INFO:               scipy: 1.11.4
2025-08-27 23:31:06,324:INFO:              joblib: 1.3.2
2025-08-27 23:31:06,324:INFO:             sklearn: 1.4.2
2025-08-27 23:31:06,324:INFO:                pyod: 2.0.5
2025-08-27 23:31:06,324:INFO:            imblearn: 0.14.0
2025-08-27 23:31:06,324:INFO:   category_encoders: 2.7.0
2025-08-27 23:31:06,324:INFO:            lightgbm: 4.6.0
2025-08-27 23:31:06,324:INFO:               numba: 0.61.0
2025-08-27 23:31:06,324:INFO:            requests: 2.32.5
2025-08-27 23:31:06,324:INFO:          matplotlib: 3.7.5
2025-08-27 23:31:06,324:INFO:          scikitplot: 0.3.7
2025-08-27 23:31:06,324:INFO:         yellowbrick: 1.5
2025-08-27 23:31:06,324:INFO:              plotly: 5.24.1
2025-08-27 23:31:06,324:INFO:    plotly-resampler: Not installed
2025-08-27 23:31:06,324:INFO:             kaleido: 1.0.0
2025-08-27 23:31:06,324:INFO:           schemdraw: 0.15
2025-08-27 23:31:06,324:INFO:         statsmodels: 0.14.5
2025-08-27 23:31:06,324:INFO:              sktime: 0.26.0
2025-08-27 23:31:06,324:INFO:               tbats: 1.1.3
2025-08-27 23:31:06,324:INFO:            pmdarima: 2.0.4
2025-08-27 23:31:06,324:INFO:              psutil: 7.0.0
2025-08-27 23:31:06,324:INFO:          markupsafe: 3.0.2
2025-08-27 23:31:06,324:INFO:             pickle5: Not installed
2025-08-27 23:31:06,324:INFO:         cloudpickle: 3.1.1
2025-08-27 23:31:06,324:INFO:         deprecation: 2.1.0
2025-08-27 23:31:06,324:INFO:              xxhash: 3.5.0
2025-08-27 23:31:06,324:INFO:           wurlitzer: Not installed
2025-08-27 23:31:06,325:INFO:PyCaret optional dependencies:
2025-08-27 23:31:10,105:INFO:                shap: 0.44.1
2025-08-27 23:31:10,105:INFO:           interpret: 0.7.2
2025-08-27 23:31:10,105:INFO:                umap: 0.5.7
2025-08-27 23:31:10,105:INFO:     ydata_profiling: 4.16.1
2025-08-27 23:31:10,105:INFO:  explainerdashboard: 0.5.1
2025-08-27 23:31:10,105:INFO:             autoviz: Not installed
2025-08-27 23:31:10,105:INFO:           fairlearn: 0.7.0
2025-08-27 23:31:10,105:INFO:          deepchecks: Not installed
2025-08-27 23:31:10,105:INFO:             xgboost: 3.0.4
2025-08-27 23:31:10,105:INFO:            catboost: 1.2.8
2025-08-27 23:31:10,105:INFO:              kmodes: 0.12.2
2025-08-27 23:31:10,105:INFO:             mlxtend: 0.23.4
2025-08-27 23:31:10,105:INFO:       statsforecast: 1.5.0
2025-08-27 23:31:10,105:INFO:        tune_sklearn: Not installed
2025-08-27 23:31:10,105:INFO:                 ray: Not installed
2025-08-27 23:31:10,105:INFO:            hyperopt: 0.2.7
2025-08-27 23:31:10,106:INFO:              optuna: 4.5.0
2025-08-27 23:31:10,106:INFO:               skopt: 0.10.2
2025-08-27 23:31:10,106:INFO:              mlflow: 3.3.1
2025-08-27 23:31:10,106:INFO:              gradio: 5.43.1
2025-08-27 23:31:10,106:INFO:             fastapi: 0.116.1
2025-08-27 23:31:10,106:INFO:             uvicorn: 0.35.0
2025-08-27 23:31:10,106:INFO:              m2cgen: 0.10.0
2025-08-27 23:31:10,106:INFO:           evidently: 0.4.40
2025-08-27 23:31:10,106:INFO:               fugue: 0.8.7
2025-08-27 23:31:10,106:INFO:           streamlit: 1.49.0
2025-08-27 23:31:10,106:INFO:             prophet: Not installed
2025-08-27 23:31:10,106:INFO:None
2025-08-27 23:31:10,106:INFO:Set up data.
2025-08-27 23:31:10,110:INFO:Set up folding strategy.
2025-08-27 23:31:10,110:INFO:Set up train/test split.
2025-08-27 23:31:10,112:INFO:Set up index.
2025-08-27 23:31:10,113:INFO:Assigning column types.
2025-08-27 23:31:10,115:INFO:Engine successfully changes for model 'lr' to 'sklearn'.
2025-08-27 23:31:10,148:INFO:Engine for model 'knn' has not been set explicitly, hence returning None.
2025-08-27 23:31:10,151:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2025-08-27 23:31:10,178:INFO:Soft dependency imported: xgboost: 3.0.4
2025-08-27 23:31:10,180:INFO:Soft dependency imported: catboost: 1.2.8
2025-08-27 23:31:10,234:INFO:Engine for model 'knn' has not been set explicitly, hence returning None.
2025-08-27 23:31:10,235:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2025-08-27 23:31:10,256:INFO:Soft dependency imported: xgboost: 3.0.4
2025-08-27 23:31:10,258:INFO:Soft dependency imported: catboost: 1.2.8
2025-08-27 23:31:10,260:INFO:Engine successfully changes for model 'knn' to 'sklearn'.
2025-08-27 23:31:10,293:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2025-08-27 23:31:10,314:INFO:Soft dependency imported: xgboost: 3.0.4
2025-08-27 23:31:10,317:INFO:Soft dependency imported: catboost: 1.2.8
2025-08-27 23:31:10,351:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2025-08-27 23:31:10,372:INFO:Soft dependency imported: xgboost: 3.0.4
2025-08-27 23:31:10,375:INFO:Soft dependency imported: catboost: 1.2.8
2025-08-27 23:31:10,375:INFO:Engine successfully changes for model 'rbfsvm' to 'sklearn'.
2025-08-27 23:31:10,430:INFO:Soft dependency imported: xgboost: 3.0.4
2025-08-27 23:31:10,433:INFO:Soft dependency imported: catboost: 1.2.8
2025-08-27 23:31:10,489:INFO:Soft dependency imported: xgboost: 3.0.4
2025-08-27 23:31:10,491:INFO:Soft dependency imported: catboost: 1.2.8
2025-08-27 23:31:10,493:INFO:Preparing preprocessing pipeline...
2025-08-27 23:31:10,494:INFO:Set up label encoding.
2025-08-27 23:31:10,494:INFO:Set up simple imputation.
2025-08-27 23:31:10,494:INFO:Set up feature normalization.
2025-08-27 23:31:10,532:INFO:Finished creating preprocessing pipeline.
2025-08-27 23:31:10,537:INFO:Pipeline: Pipeline(memory=FastMemory(location=C:\Users\javie\AppData\Local\Temp\joblib),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(exclude=None, include=None,
                                               transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(exclude=None,
                                    include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer(add_indicator=Fa...
                ('categorical_imputer',
                 TransformerWrapper(exclude=None, include=[],
                                    transformer=SimpleImputer(add_indicator=False,
                                                              copy=True,
                                                              fill_value=None,
                                                              keep_empty_features=False,
                                                              missing_values=nan,
                                                              strategy='most_frequent'))),
                ('normalize',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=StandardScaler(copy=True,
                                                               with_mean=True,
                                                               with_std=True)))],
         verbose=False)
2025-08-27 23:31:10,537:INFO:Creating final display dataframe.
2025-08-27 23:31:10,611:INFO:Setup _display_container:                     Description             Value
0                    Session id               123
1                        Target              Type
2                   Target type        Multiclass
3                Target mapping  1: 0, 2: 1, 3: 2
4           Original data shape          (199, 6)
5        Transformed data shape          (199, 6)
6   Transformed train set shape          (139, 6)
7    Transformed test set shape           (60, 6)
8              Numeric features                 5
9                    Preprocess              True
10              Imputation type            simple
11           Numeric imputation              mean
12       Categorical imputation              mode
13                    Normalize              True
14             Normalize method            zscore
15               Fold Generator   StratifiedKFold
16                  Fold Number                10
17                     CPU Jobs                -1
18                      Use GPU             False
19               Log Experiment      MlflowLogger
20              Experiment Name   wheat_seeds_cls
21                          USI              f64b
2025-08-27 23:31:10,676:INFO:Soft dependency imported: xgboost: 3.0.4
2025-08-27 23:31:10,678:INFO:Soft dependency imported: catboost: 1.2.8
2025-08-27 23:31:10,733:INFO:Soft dependency imported: xgboost: 3.0.4
2025-08-27 23:31:10,735:INFO:Soft dependency imported: catboost: 1.2.8
2025-08-27 23:31:10,737:INFO:Logging experiment in loggers
2025-08-27 23:31:10,986:INFO:SubProcess save_model() called ==================================
2025-08-27 23:31:10,994:INFO:Initializing save_model()
2025-08-27 23:31:10,994:INFO:save_model(model=Pipeline(memory=FastMemory(location=C:\Users\javie\AppData\Local\Temp\joblib),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(exclude=None, include=None,
                                               transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(exclude=None,
                                    include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer(add_indicator=Fa...
                ('categorical_imputer',
                 TransformerWrapper(exclude=None, include=[],
                                    transformer=SimpleImputer(add_indicator=False,
                                                              copy=True,
                                                              fill_value=None,
                                                              keep_empty_features=False,
                                                              missing_values=nan,
                                                              strategy='most_frequent'))),
                ('normalize',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=StandardScaler(copy=True,
                                                               with_mean=True,
                                                               with_std=True)))],
         verbose=False), model_name=C:\Users\javie\AppData\Local\Temp\tmp31gzls20\Transformation Pipeline, prep_pipe_=Pipeline(memory=FastMemory(location=C:\Users\javie\AppData\Local\Temp\joblib),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(exclude=None, include=None,
                                               transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(exclude=None,
                                    include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer(add_indicator=Fa...
                ('categorical_imputer',
                 TransformerWrapper(exclude=None, include=[],
                                    transformer=SimpleImputer(add_indicator=False,
                                                              copy=True,
                                                              fill_value=None,
                                                              keep_empty_features=False,
                                                              missing_values=nan,
                                                              strategy='most_frequent'))),
                ('normalize',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=StandardScaler(copy=True,
                                                               with_mean=True,
                                                               with_std=True)))],
         verbose=False), verbose=False, use_case=MLUsecase.CLASSIFICATION, kwargs={})
2025-08-27 23:31:10,994:INFO:Adding model into prep_pipe
2025-08-27 23:31:10,994:WARNING:Only Model saved as it was a pipeline.
2025-08-27 23:31:10,996:INFO:C:\Users\javie\AppData\Local\Temp\tmp31gzls20\Transformation Pipeline.pkl saved in current working directory
2025-08-27 23:31:11,000:INFO:Pipeline(memory=FastMemory(location=C:\Users\javie\AppData\Local\Temp\joblib),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(exclude=None, include=None,
                                               transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(exclude=None,
                                    include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer(add_indicator=Fa...
                ('categorical_imputer',
                 TransformerWrapper(exclude=None, include=[],
                                    transformer=SimpleImputer(add_indicator=False,
                                                              copy=True,
                                                              fill_value=None,
                                                              keep_empty_features=False,
                                                              missing_values=nan,
                                                              strategy='most_frequent'))),
                ('normalize',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=StandardScaler(copy=True,
                                                               with_mean=True,
                                                               with_std=True)))],
         verbose=False)
2025-08-27 23:31:11,000:INFO:save_model() successfully completed......................................
2025-08-27 23:31:11,204:INFO:SubProcess save_model() end ==================================
2025-08-27 23:31:11,319:INFO:setup() successfully completed in 5.35s...............
2025-08-27 23:31:13,912:INFO:Initializing compare_models()
2025-08-27 23:31:13,912:INFO:compare_models(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, include=None, fold=None, round=4, cross_validation=True, sort=Accuracy, n_select=1, budget_time=None, turbo=True, errors=ignore, fit_kwargs=None, groups=None, experiment_custom_tags=None, probability_threshold=None, verbose=True, parallel=None, caller_params={'self': <pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, 'include': None, 'exclude': None, 'fold': None, 'round': 4, 'cross_validation': True, 'sort': 'Accuracy', 'n_select': 1, 'budget_time': None, 'turbo': True, 'errors': 'ignore', 'fit_kwargs': None, 'groups': None, 'experiment_custom_tags': None, 'probability_threshold': None, 'engine': None, 'verbose': True, 'parallel': None, '__class__': <class 'pycaret.classification.oop.ClassificationExperiment'>}, exclude=None)
2025-08-27 23:31:13,912:INFO:Checking exceptions
2025-08-27 23:31:13,916:INFO:Preparing display monitor
2025-08-27 23:31:13,938:INFO:Initializing Logistic Regression
2025-08-27 23:31:13,938:INFO:Total runtime is 8.340676625569662e-06 minutes
2025-08-27 23:31:13,941:INFO:SubProcess create_model() called ==================================
2025-08-27 23:31:13,941:INFO:Initializing create_model()
2025-08-27 23:31:13,942:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=lr, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x0000028A9DAB59F0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2025-08-27 23:31:13,942:INFO:Checking exceptions
2025-08-27 23:31:13,942:INFO:Importing libraries
2025-08-27 23:31:13,942:INFO:Copying training dataset
2025-08-27 23:31:13,945:INFO:Defining folds
2025-08-27 23:31:13,945:INFO:Declaring metric variables
2025-08-27 23:31:13,950:INFO:Importing untrained model
2025-08-27 23:31:13,953:INFO:Logistic Regression Imported successfully
2025-08-27 23:31:13,961:INFO:Starting cross validation
2025-08-27 23:31:13,962:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2025-08-27 23:31:20,358:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:20,361:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,365:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,365:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:20,368:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,368:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,372:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,375:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,385:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:20,388:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,391:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,393:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:20,394:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,397:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,401:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,404:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,417:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:20,420:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:20,421:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,422:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:20,424:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,424:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,425:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,426:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,426:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:20,427:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,429:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,429:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,430:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,429:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:20,431:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:20,432:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,434:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,435:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,436:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,438:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,438:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,439:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,441:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,442:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,451:INFO:Calculating mean and std
2025-08-27 23:31:20,453:INFO:Creating metrics dataframe
2025-08-27 23:31:20,456:INFO:Uploading results into container
2025-08-27 23:31:20,457:INFO:Uploading model into container now
2025-08-27 23:31:20,458:INFO:_master_model_container: 1
2025-08-27 23:31:20,458:INFO:_display_container: 2
2025-08-27 23:31:20,459:INFO:LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,
                   intercept_scaling=1, l1_ratio=None, max_iter=1000,
                   multi_class='auto', n_jobs=None, penalty='l2',
                   random_state=123, solver='lbfgs', tol=0.0001, verbose=0,
                   warm_start=False)
2025-08-27 23:31:20,459:INFO:create_model() successfully completed......................................
2025-08-27 23:31:20,712:INFO:SubProcess create_model() end ==================================
2025-08-27 23:31:20,712:INFO:Creating metrics dataframe
2025-08-27 23:31:20,718:INFO:Initializing K Neighbors Classifier
2025-08-27 23:31:20,718:INFO:Total runtime is 0.11300301551818848 minutes
2025-08-27 23:31:20,720:INFO:SubProcess create_model() called ==================================
2025-08-27 23:31:20,721:INFO:Initializing create_model()
2025-08-27 23:31:20,721:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=knn, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x0000028A9DAB59F0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2025-08-27 23:31:20,721:INFO:Checking exceptions
2025-08-27 23:31:20,721:INFO:Importing libraries
2025-08-27 23:31:20,721:INFO:Copying training dataset
2025-08-27 23:31:20,724:INFO:Defining folds
2025-08-27 23:31:20,725:INFO:Declaring metric variables
2025-08-27 23:31:20,727:INFO:Importing untrained model
2025-08-27 23:31:20,731:INFO:K Neighbors Classifier Imported successfully
2025-08-27 23:31:20,737:INFO:Starting cross validation
2025-08-27 23:31:20,737:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2025-08-27 23:31:20,847:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,847:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,848:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,851:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,851:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,851:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,852:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,854:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,855:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,855:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:20,855:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:24,954:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:24,954:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:24,954:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:24,956:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:24,956:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:24,956:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:24,958:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:24,958:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:24,958:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:24,972:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:24,972:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:24,973:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:24,974:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:24,975:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:24,975:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:24,976:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:24,977:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:24,977:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:24,993:INFO:Calculating mean and std
2025-08-27 23:31:24,994:INFO:Creating metrics dataframe
2025-08-27 23:31:24,998:INFO:Uploading results into container
2025-08-27 23:31:24,999:INFO:Uploading model into container now
2025-08-27 23:31:25,000:INFO:_master_model_container: 2
2025-08-27 23:31:25,000:INFO:_display_container: 2
2025-08-27 23:31:25,000:INFO:KNeighborsClassifier(algorithm='auto', leaf_size=30, metric='minkowski',
                     metric_params=None, n_jobs=-1, n_neighbors=5, p=2,
                     weights='uniform')
2025-08-27 23:31:25,000:INFO:create_model() successfully completed......................................
2025-08-27 23:31:25,217:INFO:SubProcess create_model() end ==================================
2025-08-27 23:31:25,218:INFO:Creating metrics dataframe
2025-08-27 23:31:25,223:INFO:Initializing Naive Bayes
2025-08-27 23:31:25,223:INFO:Total runtime is 0.18808278640111287 minutes
2025-08-27 23:31:25,225:INFO:SubProcess create_model() called ==================================
2025-08-27 23:31:25,226:INFO:Initializing create_model()
2025-08-27 23:31:25,226:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=nb, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x0000028A9DAB59F0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2025-08-27 23:31:25,226:INFO:Checking exceptions
2025-08-27 23:31:25,226:INFO:Importing libraries
2025-08-27 23:31:25,226:INFO:Copying training dataset
2025-08-27 23:31:25,229:INFO:Defining folds
2025-08-27 23:31:25,229:INFO:Declaring metric variables
2025-08-27 23:31:25,232:INFO:Importing untrained model
2025-08-27 23:31:25,235:INFO:Naive Bayes Imported successfully
2025-08-27 23:31:25,239:INFO:Starting cross validation
2025-08-27 23:31:25,241:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2025-08-27 23:31:25,278:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,279:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,280:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,281:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,282:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,282:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,283:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,284:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,284:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,284:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,285:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,286:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,287:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,288:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,288:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,289:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,289:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,290:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,290:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,291:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,291:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,292:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,292:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,293:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,293:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,295:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,295:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,295:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,298:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,301:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,318:INFO:Calculating mean and std
2025-08-27 23:31:25,319:INFO:Creating metrics dataframe
2025-08-27 23:31:25,320:INFO:Uploading results into container
2025-08-27 23:31:25,321:INFO:Uploading model into container now
2025-08-27 23:31:25,321:INFO:_master_model_container: 3
2025-08-27 23:31:25,321:INFO:_display_container: 2
2025-08-27 23:31:25,321:INFO:GaussianNB(priors=None, var_smoothing=1e-09)
2025-08-27 23:31:25,321:INFO:create_model() successfully completed......................................
2025-08-27 23:31:25,493:INFO:SubProcess create_model() end ==================================
2025-08-27 23:31:25,493:INFO:Creating metrics dataframe
2025-08-27 23:31:25,499:INFO:Initializing Decision Tree Classifier
2025-08-27 23:31:25,499:INFO:Total runtime is 0.19269192218780518 minutes
2025-08-27 23:31:25,501:INFO:SubProcess create_model() called ==================================
2025-08-27 23:31:25,501:INFO:Initializing create_model()
2025-08-27 23:31:25,502:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=dt, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x0000028A9DAB59F0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2025-08-27 23:31:25,502:INFO:Checking exceptions
2025-08-27 23:31:25,502:INFO:Importing libraries
2025-08-27 23:31:25,502:INFO:Copying training dataset
2025-08-27 23:31:25,505:INFO:Defining folds
2025-08-27 23:31:25,506:INFO:Declaring metric variables
2025-08-27 23:31:25,508:INFO:Importing untrained model
2025-08-27 23:31:25,511:INFO:Decision Tree Classifier Imported successfully
2025-08-27 23:31:25,516:INFO:Starting cross validation
2025-08-27 23:31:25,517:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2025-08-27 23:31:25,551:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,553:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,555:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,555:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,557:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,558:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,558:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,560:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,561:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,561:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,562:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,562:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,563:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,563:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,563:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,565:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,565:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,566:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,566:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,567:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,567:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,568:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,569:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,569:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,569:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,570:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,570:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,571:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,572:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,574:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,582:INFO:Calculating mean and std
2025-08-27 23:31:25,582:INFO:Creating metrics dataframe
2025-08-27 23:31:25,584:INFO:Uploading results into container
2025-08-27 23:31:25,584:INFO:Uploading model into container now
2025-08-27 23:31:25,584:INFO:_master_model_container: 4
2025-08-27 23:31:25,584:INFO:_display_container: 2
2025-08-27 23:31:25,585:INFO:DecisionTreeClassifier(ccp_alpha=0.0, class_weight=None, criterion='gini',
                       max_depth=None, max_features=None, max_leaf_nodes=None,
                       min_impurity_decrease=0.0, min_samples_leaf=1,
                       min_samples_split=2, min_weight_fraction_leaf=0.0,
                       monotonic_cst=None, random_state=123, splitter='best')
2025-08-27 23:31:25,585:INFO:create_model() successfully completed......................................
2025-08-27 23:31:25,757:INFO:SubProcess create_model() end ==================================
2025-08-27 23:31:25,758:INFO:Creating metrics dataframe
2025-08-27 23:31:25,764:INFO:Initializing SVM - Linear Kernel
2025-08-27 23:31:25,764:INFO:Total runtime is 0.19710102478663127 minutes
2025-08-27 23:31:25,766:INFO:SubProcess create_model() called ==================================
2025-08-27 23:31:25,767:INFO:Initializing create_model()
2025-08-27 23:31:25,767:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=svm, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x0000028A9DAB59F0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2025-08-27 23:31:25,767:INFO:Checking exceptions
2025-08-27 23:31:25,767:INFO:Importing libraries
2025-08-27 23:31:25,767:INFO:Copying training dataset
2025-08-27 23:31:25,770:INFO:Defining folds
2025-08-27 23:31:25,770:INFO:Declaring metric variables
2025-08-27 23:31:25,774:INFO:Importing untrained model
2025-08-27 23:31:25,776:INFO:SVM - Linear Kernel Imported successfully
2025-08-27 23:31:25,782:INFO:Starting cross validation
2025-08-27 23:31:25,783:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2025-08-27 23:31:25,840:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:25,840:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:25,841:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:25,841:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:25,841:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,841:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,841:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,842:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,842:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,843:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,843:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,843:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,844:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,844:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,845:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,845:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,845:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,846:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,859:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:25,860:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,861:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:25,861:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:25,862:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:25,862:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:25,862:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,862:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,862:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,863:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,864:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,864:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,864:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,865:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,866:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,866:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,867:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,867:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,869:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,869:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:25,876:INFO:Calculating mean and std
2025-08-27 23:31:25,877:INFO:Creating metrics dataframe
2025-08-27 23:31:25,878:INFO:Uploading results into container
2025-08-27 23:31:25,879:INFO:Uploading model into container now
2025-08-27 23:31:25,879:INFO:_master_model_container: 5
2025-08-27 23:31:25,880:INFO:_display_container: 2
2025-08-27 23:31:25,880:INFO:SGDClassifier(alpha=0.0001, average=False, class_weight=None,
              early_stopping=False, epsilon=0.1, eta0=0.001, fit_intercept=True,
              l1_ratio=0.15, learning_rate='optimal', loss='hinge',
              max_iter=1000, n_iter_no_change=5, n_jobs=-1, penalty='l2',
              power_t=0.5, random_state=123, shuffle=True, tol=0.001,
              validation_fraction=0.1, verbose=0, warm_start=False)
2025-08-27 23:31:25,881:INFO:create_model() successfully completed......................................
2025-08-27 23:31:26,053:INFO:SubProcess create_model() end ==================================
2025-08-27 23:31:26,053:INFO:Creating metrics dataframe
2025-08-27 23:31:26,059:INFO:Initializing Ridge Classifier
2025-08-27 23:31:26,059:INFO:Total runtime is 0.20201855103174846 minutes
2025-08-27 23:31:26,061:INFO:SubProcess create_model() called ==================================
2025-08-27 23:31:26,061:INFO:Initializing create_model()
2025-08-27 23:31:26,061:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=ridge, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x0000028A9DAB59F0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2025-08-27 23:31:26,062:INFO:Checking exceptions
2025-08-27 23:31:26,062:INFO:Importing libraries
2025-08-27 23:31:26,062:INFO:Copying training dataset
2025-08-27 23:31:26,065:INFO:Defining folds
2025-08-27 23:31:26,065:INFO:Declaring metric variables
2025-08-27 23:31:26,069:INFO:Importing untrained model
2025-08-27 23:31:26,072:INFO:Ridge Classifier Imported successfully
2025-08-27 23:31:26,077:INFO:Starting cross validation
2025-08-27 23:31:26,078:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2025-08-27 23:31:26,111:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:26,114:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,117:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:26,117:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:26,117:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,118:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,119:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:26,119:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,120:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,120:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,121:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,121:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:26,122:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,122:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,122:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:26,123:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:26,123:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,123:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:26,124:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,124:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,124:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,125:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,125:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,125:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:26,125:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,126:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,126:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,127:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,127:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,127:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,129:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,129:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,129:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,130:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

ead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:26,131:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,131:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,132:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,134:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,136:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,155:INFO:Calculating mean and std
2025-08-27 23:31:26,156:INFO:Creating metrics dataframe
2025-08-27 23:31:26,157:INFO:Uploading results into container
2025-08-27 23:31:26,157:INFO:Uploading model into container now
2025-08-27 23:31:26,158:INFO:_master_model_container: 6
2025-08-27 23:31:26,158:INFO:_display_container: 2
2025-08-27 23:31:26,158:INFO:RidgeClassifier(alpha=1.0, class_weight=None, copy_X=True, fit_intercept=True,
                max_iter=None, positive=False, random_state=123, solver='auto',
                tol=0.0001)
2025-08-27 23:31:26,158:INFO:create_model() successfully completed......................................
2025-08-27 23:31:26,331:INFO:SubProcess create_model() end ==================================
2025-08-27 23:31:26,331:INFO:Creating metrics dataframe
2025-08-27 23:31:26,338:INFO:Initializing Random Forest Classifier
2025-08-27 23:31:26,338:INFO:Total runtime is 0.20666935841242473 minutes
2025-08-27 23:31:26,340:INFO:SubProcess create_model() called ==================================
2025-08-27 23:31:26,340:INFO:Initializing create_model()
2025-08-27 23:31:26,340:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=rf, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x0000028A9DAB59F0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2025-08-27 23:31:26,340:INFO:Checking exceptions
2025-08-27 23:31:26,341:INFO:Importing libraries
2025-08-27 23:31:26,341:INFO:Copying training dataset
2025-08-27 23:31:26,344:INFO:Defining folds
2025-08-27 23:31:26,344:INFO:Declaring metric variables
2025-08-27 23:31:26,347:INFO:Importing untrained model
2025-08-27 23:31:26,350:INFO:Random Forest Classifier Imported successfully
2025-08-27 23:31:26,358:INFO:Starting cross validation
2025-08-27 23:31:26,359:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2025-08-27 23:31:26,627:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,627:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,627:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,627:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,628:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,629:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,630:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,631:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,631:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,631:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,631:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,633:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,633:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,634:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,634:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,642:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,642:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,642:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,642:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,644:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,644:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,644:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,645:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,646:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,646:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,647:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,647:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,656:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,658:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,660:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,666:INFO:Calculating mean and std
2025-08-27 23:31:26,668:INFO:Creating metrics dataframe
2025-08-27 23:31:26,669:INFO:Uploading results into container
2025-08-27 23:31:26,669:INFO:Uploading model into container now
2025-08-27 23:31:26,670:INFO:_master_model_container: 7
2025-08-27 23:31:26,670:INFO:_display_container: 2
2025-08-27 23:31:26,670:INFO:RandomForestClassifier(bootstrap=True, ccp_alpha=0.0, class_weight=None,
                       criterion='gini', max_depth=None, max_features='sqrt',
                       max_leaf_nodes=None, max_samples=None,
                       min_impurity_decrease=0.0, min_samples_leaf=1,
                       min_samples_split=2, min_weight_fraction_leaf=0.0,
                       monotonic_cst=None, n_estimators=100, n_jobs=-1,
                       oob_score=False, random_state=123, verbose=0,
                       warm_start=False)
2025-08-27 23:31:26,670:INFO:create_model() successfully completed......................................
2025-08-27 23:31:26,842:INFO:SubProcess create_model() end ==================================
2025-08-27 23:31:26,843:INFO:Creating metrics dataframe
2025-08-27 23:31:26,849:INFO:Initializing Quadratic Discriminant Analysis
2025-08-27 23:31:26,849:INFO:Total runtime is 0.2151958425839742 minutes
2025-08-27 23:31:26,852:INFO:SubProcess create_model() called ==================================
2025-08-27 23:31:26,852:INFO:Initializing create_model()
2025-08-27 23:31:26,852:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=qda, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x0000028A9DAB59F0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2025-08-27 23:31:26,852:INFO:Checking exceptions
2025-08-27 23:31:26,852:INFO:Importing libraries
2025-08-27 23:31:26,852:INFO:Copying training dataset
2025-08-27 23:31:26,855:INFO:Defining folds
2025-08-27 23:31:26,855:INFO:Declaring metric variables
2025-08-27 23:31:26,858:INFO:Importing untrained model
2025-08-27 23:31:26,861:INFO:Quadratic Discriminant Analysis Imported successfully
2025-08-27 23:31:26,866:INFO:Starting cross validation
2025-08-27 23:31:26,867:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2025-08-27 23:31:26,904:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:26,904:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:26,905:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,906:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,907:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:26,907:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:26,907:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,908:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,908:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,908:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,909:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:26,909:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:26,910:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,910:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,910:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,910:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,910:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,911:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,912:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:26,912:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,912:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,913:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,913:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,913:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,914:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:26,916:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,916:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,916:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:26,916:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,917:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,918:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,919:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,919:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:26,919:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,920:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,920:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,921:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,922:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,923:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,924:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:26,930:INFO:Calculating mean and std
2025-08-27 23:31:26,931:INFO:Creating metrics dataframe
2025-08-27 23:31:26,932:INFO:Uploading results into container
2025-08-27 23:31:26,932:INFO:Uploading model into container now
2025-08-27 23:31:26,933:INFO:_master_model_container: 8
2025-08-27 23:31:26,933:INFO:_display_container: 2
2025-08-27 23:31:26,933:INFO:QuadraticDiscriminantAnalysis(priors=None, reg_param=0.0,
                              store_covariance=False, tol=0.0001)
2025-08-27 23:31:26,933:INFO:create_model() successfully completed......................................
2025-08-27 23:31:27,105:INFO:SubProcess create_model() end ==================================
2025-08-27 23:31:27,106:INFO:Creating metrics dataframe
2025-08-27 23:31:27,112:INFO:Initializing Ada Boost Classifier
2025-08-27 23:31:27,112:INFO:Total runtime is 0.2195799469947815 minutes
2025-08-27 23:31:27,115:INFO:SubProcess create_model() called ==================================
2025-08-27 23:31:27,115:INFO:Initializing create_model()
2025-08-27 23:31:27,115:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=ada, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x0000028A9DAB59F0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2025-08-27 23:31:27,115:INFO:Checking exceptions
2025-08-27 23:31:27,115:INFO:Importing libraries
2025-08-27 23:31:27,115:INFO:Copying training dataset
2025-08-27 23:31:27,118:INFO:Defining folds
2025-08-27 23:31:27,118:INFO:Declaring metric variables
2025-08-27 23:31:27,121:INFO:Importing untrained model
2025-08-27 23:31:27,124:INFO:Ada Boost Classifier Imported successfully
2025-08-27 23:31:27,129:INFO:Starting cross validation
2025-08-27 23:31:27,130:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2025-08-27 23:31:27,151:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\ensemble\_weight_boosting.py:519: FutureWarning: The SAMME.R algorithm (the default) is deprecated and will be removed in 1.6. Use the SAMME algorithm to circumvent this warning.
  warnings.warn(

2025-08-27 23:31:27,157:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\ensemble\_weight_boosting.py:519: FutureWarning: The SAMME.R algorithm (the default) is deprecated and will be removed in 1.6. Use the SAMME algorithm to circumvent this warning.
  warnings.warn(

2025-08-27 23:31:27,157:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\ensemble\_weight_boosting.py:519: FutureWarning: The SAMME.R algorithm (the default) is deprecated and will be removed in 1.6. Use the SAMME algorithm to circumvent this warning.
  warnings.warn(

2025-08-27 23:31:27,157:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\ensemble\_weight_boosting.py:519: FutureWarning: The SAMME.R algorithm (the default) is deprecated and will be removed in 1.6. Use the SAMME algorithm to circumvent this warning.
  warnings.warn(

2025-08-27 23:31:27,160:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\ensemble\_weight_boosting.py:519: FutureWarning: The SAMME.R algorithm (the default) is deprecated and will be removed in 1.6. Use the SAMME algorithm to circumvent this warning.
  warnings.warn(

2025-08-27 23:31:27,161:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\ensemble\_weight_boosting.py:519: FutureWarning: The SAMME.R algorithm (the default) is deprecated and will be removed in 1.6. Use the SAMME algorithm to circumvent this warning.
  warnings.warn(

2025-08-27 23:31:27,162:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\ensemble\_weight_boosting.py:519: FutureWarning: The SAMME.R algorithm (the default) is deprecated and will be removed in 1.6. Use the SAMME algorithm to circumvent this warning.
  warnings.warn(

2025-08-27 23:31:27,164:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\ensemble\_weight_boosting.py:519: FutureWarning: The SAMME.R algorithm (the default) is deprecated and will be removed in 1.6. Use the SAMME algorithm to circumvent this warning.
  warnings.warn(

2025-08-27 23:31:27,167:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\ensemble\_weight_boosting.py:519: FutureWarning: The SAMME.R algorithm (the default) is deprecated and will be removed in 1.6. Use the SAMME algorithm to circumvent this warning.
  warnings.warn(

2025-08-27 23:31:27,170:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\ensemble\_weight_boosting.py:519: FutureWarning: The SAMME.R algorithm (the default) is deprecated and will be removed in 1.6. Use the SAMME algorithm to circumvent this warning.
  warnings.warn(

2025-08-27 23:31:27,256:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:27,257:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,259:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,260:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:27,262:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,262:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,265:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,266:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:27,267:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,268:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,270:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,270:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:27,271:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:27,272:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,272:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,273:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:27,274:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,274:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,275:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,277:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,276:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:27,277:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,278:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,278:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,278:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:27,279:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:27,279:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,280:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,281:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,281:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,282:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,283:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,283:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,283:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,285:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:27,285:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,286:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,288:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,290:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,302:INFO:Calculating mean and std
2025-08-27 23:31:27,303:INFO:Creating metrics dataframe
2025-08-27 23:31:27,305:INFO:Uploading results into container
2025-08-27 23:31:27,305:INFO:Uploading model into container now
2025-08-27 23:31:27,306:INFO:_master_model_container: 9
2025-08-27 23:31:27,306:INFO:_display_container: 2
2025-08-27 23:31:27,306:INFO:AdaBoostClassifier(algorithm='SAMME.R', estimator=None, learning_rate=1.0,
                   n_estimators=50, random_state=123)
2025-08-27 23:31:27,306:INFO:create_model() successfully completed......................................
2025-08-27 23:31:27,477:INFO:SubProcess create_model() end ==================================
2025-08-27 23:31:27,477:INFO:Creating metrics dataframe
2025-08-27 23:31:27,484:INFO:Initializing Gradient Boosting Classifier
2025-08-27 23:31:27,485:INFO:Total runtime is 0.22578936020533244 minutes
2025-08-27 23:31:27,487:INFO:SubProcess create_model() called ==================================
2025-08-27 23:31:27,487:INFO:Initializing create_model()
2025-08-27 23:31:27,487:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=gbc, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x0000028A9DAB59F0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2025-08-27 23:31:27,487:INFO:Checking exceptions
2025-08-27 23:31:27,487:INFO:Importing libraries
2025-08-27 23:31:27,487:INFO:Copying training dataset
2025-08-27 23:31:27,490:INFO:Defining folds
2025-08-27 23:31:27,490:INFO:Declaring metric variables
2025-08-27 23:31:27,493:INFO:Importing untrained model
2025-08-27 23:31:27,495:INFO:Gradient Boosting Classifier Imported successfully
2025-08-27 23:31:27,500:INFO:Starting cross validation
2025-08-27 23:31:27,502:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2025-08-27 23:31:27,849:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:27,851:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,853:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,856:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,860:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:27,862:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,864:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,867:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,875:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:27,875:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:27,877:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,877:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,877:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:27,878:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,879:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,880:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:27,880:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,881:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,881:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:27,882:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,882:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,883:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,883:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,884:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,884:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,884:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:27,885:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:27,885:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,885:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,885:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,886:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,887:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,888:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,888:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,890:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,890:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:27,891:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,892:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,893:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,895:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:27,907:INFO:Calculating mean and std
2025-08-27 23:31:27,908:INFO:Creating metrics dataframe
2025-08-27 23:31:27,910:INFO:Uploading results into container
2025-08-27 23:31:27,910:INFO:Uploading model into container now
2025-08-27 23:31:27,910:INFO:_master_model_container: 10
2025-08-27 23:31:27,910:INFO:_display_container: 2
2025-08-27 23:31:27,911:INFO:GradientBoostingClassifier(ccp_alpha=0.0, criterion='friedman_mse', init=None,
                           learning_rate=0.1, loss='log_loss', max_depth=3,
                           max_features=None, max_leaf_nodes=None,
                           min_impurity_decrease=0.0, min_samples_leaf=1,
                           min_samples_split=2, min_weight_fraction_leaf=0.0,
                           n_estimators=100, n_iter_no_change=None,
                           random_state=123, subsample=1.0, tol=0.0001,
                           validation_fraction=0.1, verbose=0,
                           warm_start=False)
2025-08-27 23:31:27,911:INFO:create_model() successfully completed......................................
2025-08-27 23:31:28,085:INFO:SubProcess create_model() end ==================================
2025-08-27 23:31:28,085:INFO:Creating metrics dataframe
2025-08-27 23:31:28,092:INFO:Initializing Linear Discriminant Analysis
2025-08-27 23:31:28,092:INFO:Total runtime is 0.23590779304504395 minutes
2025-08-27 23:31:28,095:INFO:SubProcess create_model() called ==================================
2025-08-27 23:31:28,095:INFO:Initializing create_model()
2025-08-27 23:31:28,095:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=lda, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x0000028A9DAB59F0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2025-08-27 23:31:28,095:INFO:Checking exceptions
2025-08-27 23:31:28,095:INFO:Importing libraries
2025-08-27 23:31:28,095:INFO:Copying training dataset
2025-08-27 23:31:28,098:INFO:Defining folds
2025-08-27 23:31:28,098:INFO:Declaring metric variables
2025-08-27 23:31:28,102:INFO:Importing untrained model
2025-08-27 23:31:28,105:INFO:Linear Discriminant Analysis Imported successfully
2025-08-27 23:31:28,111:INFO:Starting cross validation
2025-08-27 23:31:28,112:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2025-08-27 23:31:28,145:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:28,145:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:28,146:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,147:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,148:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,150:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:28,150:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:28,150:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,151:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,151:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,151:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,152:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,152:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:28,154:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,154:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:28,154:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:28,155:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,155:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,155:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:28,156:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,157:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,157:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,157:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,157:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,158:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,159:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,159:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:28,159:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:31:28,159:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,160:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,160:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,160:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,160:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,161:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,162:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,163:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,163:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,166:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,166:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,186:INFO:Calculating mean and std
2025-08-27 23:31:28,187:INFO:Creating metrics dataframe
2025-08-27 23:31:28,189:INFO:Uploading results into container
2025-08-27 23:31:28,189:INFO:Uploading model into container now
2025-08-27 23:31:28,190:INFO:_master_model_container: 11
2025-08-27 23:31:28,190:INFO:_display_container: 2
2025-08-27 23:31:28,190:INFO:LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001)
2025-08-27 23:31:28,190:INFO:create_model() successfully completed......................................
2025-08-27 23:31:28,364:INFO:SubProcess create_model() end ==================================
2025-08-27 23:31:28,364:INFO:Creating metrics dataframe
2025-08-27 23:31:28,372:INFO:Initializing Extra Trees Classifier
2025-08-27 23:31:28,372:INFO:Total runtime is 0.2405669371287028 minutes
2025-08-27 23:31:28,374:INFO:SubProcess create_model() called ==================================
2025-08-27 23:31:28,374:INFO:Initializing create_model()
2025-08-27 23:31:28,375:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=et, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x0000028A9DAB59F0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2025-08-27 23:31:28,375:INFO:Checking exceptions
2025-08-27 23:31:28,375:INFO:Importing libraries
2025-08-27 23:31:28,375:INFO:Copying training dataset
2025-08-27 23:31:28,377:INFO:Defining folds
2025-08-27 23:31:28,378:INFO:Declaring metric variables
2025-08-27 23:31:28,380:INFO:Importing untrained model
2025-08-27 23:31:28,383:INFO:Extra Trees Classifier Imported successfully
2025-08-27 23:31:28,388:INFO:Starting cross validation
2025-08-27 23:31:28,389:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2025-08-27 23:31:28,614:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,614:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,614:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,614:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,614:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,615:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,615:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,618:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,618:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,618:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,619:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,619:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,619:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,619:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,619:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,622:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,622:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,622:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,622:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,622:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,622:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,622:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,623:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,641:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,641:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,642:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,642:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,644:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,644:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:28,651:INFO:Calculating mean and std
2025-08-27 23:31:28,652:INFO:Creating metrics dataframe
2025-08-27 23:31:28,654:INFO:Uploading results into container
2025-08-27 23:31:28,654:INFO:Uploading model into container now
2025-08-27 23:31:28,654:INFO:_master_model_container: 12
2025-08-27 23:31:28,655:INFO:_display_container: 2
2025-08-27 23:31:28,655:INFO:ExtraTreesClassifier(bootstrap=False, ccp_alpha=0.0, class_weight=None,
                     criterion='gini', max_depth=None, max_features='sqrt',
                     max_leaf_nodes=None, max_samples=None,
                     min_impurity_decrease=0.0, min_samples_leaf=1,
                     min_samples_split=2, min_weight_fraction_leaf=0.0,
                     monotonic_cst=None, n_estimators=100, n_jobs=-1,
                     oob_score=False, random_state=123, verbose=0,
                     warm_start=False)
2025-08-27 23:31:28,655:INFO:create_model() successfully completed......................................
2025-08-27 23:31:28,843:INFO:SubProcess create_model() end ==================================
2025-08-27 23:31:28,843:INFO:Creating metrics dataframe
2025-08-27 23:31:28,851:INFO:Initializing Extreme Gradient Boosting
2025-08-27 23:31:28,851:INFO:Total runtime is 0.24855165084203085 minutes
2025-08-27 23:31:28,854:INFO:SubProcess create_model() called ==================================
2025-08-27 23:31:28,854:INFO:Initializing create_model()
2025-08-27 23:31:28,854:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=xgboost, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x0000028A9DAB59F0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2025-08-27 23:31:28,855:INFO:Checking exceptions
2025-08-27 23:31:28,855:INFO:Importing libraries
2025-08-27 23:31:28,855:INFO:Copying training dataset
2025-08-27 23:31:28,858:INFO:Defining folds
2025-08-27 23:31:28,858:INFO:Declaring metric variables
2025-08-27 23:31:28,861:INFO:Importing untrained model
2025-08-27 23:31:28,865:INFO:Extreme Gradient Boosting Imported successfully
2025-08-27 23:31:28,870:INFO:Starting cross validation
2025-08-27 23:31:28,871:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2025-08-27 23:31:29,406:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,408:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,410:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,427:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,429:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,432:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,439:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,441:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,444:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,463:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,466:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,466:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,467:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,468:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,469:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,470:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,470:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,471:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,474:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,476:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,478:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,479:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,481:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,483:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,484:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,486:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,488:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,492:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,493:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,495:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:29,503:INFO:Calculating mean and std
2025-08-27 23:31:29,505:INFO:Creating metrics dataframe
2025-08-27 23:31:29,506:INFO:Uploading results into container
2025-08-27 23:31:29,506:INFO:Uploading model into container now
2025-08-27 23:31:29,507:INFO:_master_model_container: 13
2025-08-27 23:31:29,507:INFO:_display_container: 2
2025-08-27 23:31:29,507:INFO:XGBClassifier(base_score=None, booster='gbtree', callbacks=None,
              colsample_bylevel=None, colsample_bynode=None,
              colsample_bytree=None, device='cpu', early_stopping_rounds=None,
              enable_categorical=False, eval_metric=None, feature_types=None,
              feature_weights=None, gamma=None, grow_policy=None,
              importance_type=None, interaction_constraints=None,
              learning_rate=None, max_bin=None, max_cat_threshold=None,
              max_cat_to_onehot=None, max_delta_step=None, max_depth=None,
              max_leaves=None, min_child_weight=None, missing=nan,
              monotone_constraints=None, multi_strategy=None, n_estimators=None,
              n_jobs=-1, num_parallel_tree=None, ...)
2025-08-27 23:31:29,508:INFO:create_model() successfully completed......................................
2025-08-27 23:31:29,682:INFO:SubProcess create_model() end ==================================
2025-08-27 23:31:29,682:INFO:Creating metrics dataframe
2025-08-27 23:31:29,690:INFO:Initializing Light Gradient Boosting Machine
2025-08-27 23:31:29,690:INFO:Total runtime is 0.2625374356905619 minutes
2025-08-27 23:31:29,692:INFO:SubProcess create_model() called ==================================
2025-08-27 23:31:29,692:INFO:Initializing create_model()
2025-08-27 23:31:29,692:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=lightgbm, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x0000028A9DAB59F0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2025-08-27 23:31:29,693:INFO:Checking exceptions
2025-08-27 23:31:29,693:INFO:Importing libraries
2025-08-27 23:31:29,693:INFO:Copying training dataset
2025-08-27 23:31:29,696:INFO:Defining folds
2025-08-27 23:31:29,696:INFO:Declaring metric variables
2025-08-27 23:31:29,700:INFO:Importing untrained model
2025-08-27 23:31:29,703:INFO:Light Gradient Boosting Machine Imported successfully
2025-08-27 23:31:29,709:INFO:Starting cross validation
2025-08-27 23:31:29,710:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2025-08-27 23:31:31,080:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,082:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,086:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,132:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,135:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,139:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,152:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,156:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,156:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,159:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,159:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,166:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,169:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,170:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,173:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,174:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,177:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,197:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,200:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,202:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,203:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,205:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,208:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,218:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,221:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,224:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,229:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,232:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,235:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:31,255:INFO:Calculating mean and std
2025-08-27 23:31:31,257:INFO:Creating metrics dataframe
2025-08-27 23:31:31,259:INFO:Uploading results into container
2025-08-27 23:31:31,260:INFO:Uploading model into container now
2025-08-27 23:31:31,260:INFO:_master_model_container: 14
2025-08-27 23:31:31,260:INFO:_display_container: 2
2025-08-27 23:31:31,261:INFO:LGBMClassifier(boosting_type='gbdt', class_weight=None, colsample_bytree=1.0,
               importance_type='split', learning_rate=0.1, max_depth=-1,
               min_child_samples=20, min_child_weight=0.001, min_split_gain=0.0,
               n_estimators=100, n_jobs=-1, num_leaves=31, objective=None,
               random_state=123, reg_alpha=0.0, reg_lambda=0.0, subsample=1.0,
               subsample_for_bin=200000, subsample_freq=0)
2025-08-27 23:31:31,261:INFO:create_model() successfully completed......................................
2025-08-27 23:31:31,448:INFO:SubProcess create_model() end ==================================
2025-08-27 23:31:31,448:INFO:Creating metrics dataframe
2025-08-27 23:31:31,456:INFO:Initializing CatBoost Classifier
2025-08-27 23:31:31,456:INFO:Total runtime is 0.29196756283442177 minutes
2025-08-27 23:31:31,458:INFO:SubProcess create_model() called ==================================
2025-08-27 23:31:31,458:INFO:Initializing create_model()
2025-08-27 23:31:31,458:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=catboost, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x0000028A9DAB59F0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2025-08-27 23:31:31,458:INFO:Checking exceptions
2025-08-27 23:31:31,459:INFO:Importing libraries
2025-08-27 23:31:31,459:INFO:Copying training dataset
2025-08-27 23:31:31,461:INFO:Defining folds
2025-08-27 23:31:31,461:INFO:Declaring metric variables
2025-08-27 23:31:31,465:INFO:Importing untrained model
2025-08-27 23:31:31,468:INFO:CatBoost Classifier Imported successfully
2025-08-27 23:31:31,475:INFO:Starting cross validation
2025-08-27 23:31:31,476:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2025-08-27 23:31:34,328:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:34,331:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:34,334:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,234:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,239:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,243:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,293:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,297:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,302:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,305:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,308:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,312:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,324:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,328:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,331:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,357:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,357:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,358:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,359:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,359:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,361:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,361:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,361:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,362:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,369:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,371:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,373:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,373:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,375:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,377:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,387:INFO:Calculating mean and std
2025-08-27 23:31:36,388:INFO:Creating metrics dataframe
2025-08-27 23:31:36,390:INFO:Uploading results into container
2025-08-27 23:31:36,390:INFO:Uploading model into container now
2025-08-27 23:31:36,390:INFO:_master_model_container: 15
2025-08-27 23:31:36,390:INFO:_display_container: 2
2025-08-27 23:31:36,391:INFO:<catboost.core.CatBoostClassifier object at 0x0000028AA5BCBA00>
2025-08-27 23:31:36,391:INFO:create_model() successfully completed......................................
2025-08-27 23:31:36,565:INFO:SubProcess create_model() end ==================================
2025-08-27 23:31:36,565:INFO:Creating metrics dataframe
2025-08-27 23:31:36,573:INFO:Initializing Dummy Classifier
2025-08-27 23:31:36,573:INFO:Total runtime is 0.37725743452707927 minutes
2025-08-27 23:31:36,575:INFO:SubProcess create_model() called ==================================
2025-08-27 23:31:36,576:INFO:Initializing create_model()
2025-08-27 23:31:36,576:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=dummy, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x0000028A9DAB59F0>, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2025-08-27 23:31:36,576:INFO:Checking exceptions
2025-08-27 23:31:36,576:INFO:Importing libraries
2025-08-27 23:31:36,576:INFO:Copying training dataset
2025-08-27 23:31:36,579:INFO:Defining folds
2025-08-27 23:31:36,579:INFO:Declaring metric variables
2025-08-27 23:31:36,582:INFO:Importing untrained model
2025-08-27 23:31:36,586:INFO:Dummy Classifier Imported successfully
2025-08-27 23:31:36,591:INFO:Starting cross validation
2025-08-27 23:31:36,592:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2025-08-27 23:31:36,625:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,625:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,627:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,627:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,628:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1509: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, f"{metric.capitalize()} is", len(result))

2025-08-27 23:31:36,629:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,629:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,629:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,629:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,630:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,630:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1509: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, f"{metric.capitalize()} is", len(result))

2025-08-27 23:31:36,631:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1509: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, f"{metric.capitalize()} is", len(result))

2025-08-27 23:31:36,631:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,632:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,632:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1509: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, f"{metric.capitalize()} is", len(result))

2025-08-27 23:31:36,632:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,633:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,633:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,633:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,634:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,634:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1509: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, f"{metric.capitalize()} is", len(result))

2025-08-27 23:31:36,636:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,636:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,636:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,637:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1509: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, f"{metric.capitalize()} is", len(result))

2025-08-27 23:31:36,637:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,637:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1509: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, f"{metric.capitalize()} is", len(result))

2025-08-27 23:31:36,638:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,638:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,639:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,639:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,640:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,640:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1509: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, f"{metric.capitalize()} is", len(result))

2025-08-27 23:31:36,641:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,641:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,642:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1509: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, f"{metric.capitalize()} is", len(result))

2025-08-27 23:31:36,642:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,643:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,643:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1509: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, f"{metric.capitalize()} is", len(result))

2025-08-27 23:31:36,645:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:31:36,650:INFO:Calculating mean and std
2025-08-27 23:31:36,651:INFO:Creating metrics dataframe
2025-08-27 23:31:36,652:INFO:Uploading results into container
2025-08-27 23:31:36,653:INFO:Uploading model into container now
2025-08-27 23:31:36,653:INFO:_master_model_container: 16
2025-08-27 23:31:36,653:INFO:_display_container: 2
2025-08-27 23:31:36,653:INFO:DummyClassifier(constant=None, random_state=123, strategy='prior')
2025-08-27 23:31:36,653:INFO:create_model() successfully completed......................................
2025-08-27 23:31:36,827:INFO:SubProcess create_model() end ==================================
2025-08-27 23:31:36,827:INFO:Creating metrics dataframe
2025-08-27 23:31:36,836:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py:323: FutureWarning: Styler.applymap has been deprecated. Use Styler.map instead.

2025-08-27 23:31:36,841:INFO:Initializing create_model()
2025-08-27 23:31:36,842:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001), fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=False, predict=False, fit_kwargs={}, groups=None, refit=True, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=None, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2025-08-27 23:31:36,842:INFO:Checking exceptions
2025-08-27 23:31:36,843:INFO:Importing libraries
2025-08-27 23:31:36,843:INFO:Copying training dataset
2025-08-27 23:31:36,846:INFO:Defining folds
2025-08-27 23:31:36,847:INFO:Declaring metric variables
2025-08-27 23:31:36,847:INFO:Importing untrained model
2025-08-27 23:31:36,847:INFO:Declaring custom model
2025-08-27 23:31:36,847:INFO:Linear Discriminant Analysis Imported successfully
2025-08-27 23:31:36,848:INFO:Cross validation set to False
2025-08-27 23:31:36,848:INFO:Fitting Model
2025-08-27 23:31:36,857:INFO:LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001)
2025-08-27 23:31:36,857:INFO:create_model() successfully completed......................................
2025-08-27 23:31:37,036:INFO:Creating Dashboard logs
2025-08-27 23:31:37,038:INFO:Model: Linear Discriminant Analysis
2025-08-27 23:31:37,129:INFO:Logged params: {'covariance_estimator': None, 'n_components': None, 'priors': None, 'shrinkage': None, 'solver': 'svd', 'store_covariance': False, 'tol': 0.0001}
2025-08-27 23:31:37,332:INFO:Initializing predict_model()
2025-08-27 23:31:37,332:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=False, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x0000028AA53691B0>)
2025-08-27 23:31:37,332:INFO:Checking exceptions
2025-08-27 23:31:37,332:INFO:Preloading libraries
2025-08-27 23:31:37,372:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.

2025-08-27 23:31:37,373:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.

2025-08-27 23:31:37,375:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.

2025-08-27 23:31:37,581:INFO:SubProcess plot_model() called ==================================
2025-08-27 23:31:37,582:INFO:Initializing plot_model()
2025-08-27 23:31:37,582:INFO:plot_model(plot=auc, fold=None, verbose=False, display=None, display_format=None, estimator=LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001), feature_name=None, fit_kwargs=None, groups=None, label=False, plot_kwargs=None, save=C:\Users\javie\AppData\Local\Temp\tmpymmu22y6, scale=1, self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, system=False)
2025-08-27 23:31:37,582:INFO:Checking exceptions
2025-08-27 23:31:37,583:INFO:Preloading libraries
2025-08-27 23:31:37,583:INFO:Copying training dataset
2025-08-27 23:31:37,583:INFO:Plot type: auc
2025-08-27 23:31:37,647:INFO:Fitting Model
2025-08-27 23:31:37,647:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\base.py:493: UserWarning: X does not have valid feature names, but LinearDiscriminantAnalysis was fitted with feature names

2025-08-27 23:31:37,647:INFO:Scoring test/hold-out set
2025-08-27 23:31:37,668:INFO:Saving 'C:\Users\javie\AppData\Local\Temp\tmpymmu22y6\AUC.png'
2025-08-27 23:31:37,847:INFO:Visual Rendered Successfully
2025-08-27 23:31:38,023:INFO:plot_model() successfully completed......................................
2025-08-27 23:31:38,042:INFO:Initializing plot_model()
2025-08-27 23:31:38,042:INFO:plot_model(plot=confusion_matrix, fold=None, verbose=False, display=None, display_format=None, estimator=LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001), feature_name=None, fit_kwargs=None, groups=None, label=False, plot_kwargs=None, save=C:\Users\javie\AppData\Local\Temp\tmpymmu22y6, scale=1, self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, system=False)
2025-08-27 23:31:38,043:INFO:Checking exceptions
2025-08-27 23:31:38,044:INFO:Preloading libraries
2025-08-27 23:31:38,044:INFO:Copying training dataset
2025-08-27 23:31:38,044:INFO:Plot type: confusion_matrix
2025-08-27 23:31:38,107:INFO:Fitting Model
2025-08-27 23:31:38,107:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\base.py:493: UserWarning: X does not have valid feature names, but LinearDiscriminantAnalysis was fitted with feature names

2025-08-27 23:31:38,107:INFO:Scoring test/hold-out set
2025-08-27 23:31:38,123:INFO:Saving 'C:\Users\javie\AppData\Local\Temp\tmpymmu22y6\Confusion Matrix.png'
2025-08-27 23:31:38,220:INFO:Visual Rendered Successfully
2025-08-27 23:31:38,394:INFO:plot_model() successfully completed......................................
2025-08-27 23:31:38,414:INFO:Initializing plot_model()
2025-08-27 23:31:38,414:INFO:plot_model(plot=feature, fold=None, verbose=False, display=None, display_format=None, estimator=LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001), feature_name=None, fit_kwargs=None, groups=None, label=False, plot_kwargs=None, save=C:\Users\javie\AppData\Local\Temp\tmpymmu22y6, scale=1, self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, system=False)
2025-08-27 23:31:38,414:INFO:Checking exceptions
2025-08-27 23:31:38,415:INFO:Preloading libraries
2025-08-27 23:31:38,415:INFO:Copying training dataset
2025-08-27 23:31:38,415:INFO:Plot type: feature
2025-08-27 23:31:38,477:INFO:Saving 'C:\Users\javie\AppData\Local\Temp\tmpymmu22y6\Feature Importance.png'
2025-08-27 23:31:38,563:INFO:Visual Rendered Successfully
2025-08-27 23:31:38,741:INFO:plot_model() successfully completed......................................
2025-08-27 23:31:38,761:INFO:SubProcess plot_model() end ==================================
2025-08-27 23:31:38,763:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\_distutils_hack\__init__.py:30: UserWarning: Setuptools is replacing distutils. Support for replacing an already imported distutils is deprecated. In the future, this condition will fail. Register concerns at https://github.com/pypa/setuptools/issues/new?template=distutils-deprecation.yml

2025-08-27 23:31:41,587:INFO:Creating Dashboard logs
2025-08-27 23:31:41,590:INFO:Model: Quadratic Discriminant Analysis
2025-08-27 23:31:41,649:INFO:Logged params: {'priors': None, 'reg_param': 0.0, 'store_covariance': False, 'tol': 0.0001}
2025-08-27 23:31:42,162:INFO:Creating Dashboard logs
2025-08-27 23:31:42,165:INFO:Model: Ridge Classifier
2025-08-27 23:31:42,224:INFO:Logged params: {'alpha': 1.0, 'class_weight': None, 'copy_X': True, 'fit_intercept': True, 'max_iter': None, 'positive': False, 'random_state': 123, 'solver': 'auto', 'tol': 0.0001}
2025-08-27 23:31:42,735:INFO:Creating Dashboard logs
2025-08-27 23:31:42,738:INFO:Model: Extreme Gradient Boosting
2025-08-27 23:31:42,798:INFO:Logged params: {'objective': 'binary:logistic', 'base_score': None, 'booster': 'gbtree', 'callbacks': None, 'colsample_bylevel': None, 'colsample_bynode': None, 'colsample_bytree': None, 'device': 'cpu', 'early_stopping_rounds': None, 'enable_categorical': False, 'eval_metric': None, 'feature_types': None, 'feature_weights': None, 'gamma': None, 'grow_policy': None, 'importance_type': None, 'interaction_constraints': None, 'learning_rate': None, 'max_bin': None, 'max_cat_threshold': None, 'max_cat_to_onehot': None, 'max_delta_step': None, 'max_depth': None, 'max_leaves': None, 'min_child_weight': None, 'missing': nan, 'monotone_constraints': None, 'multi_strategy': None, 'n_estimators': None, 'n_jobs': -1, 'num_parallel_tree': None, 'random_state': 123, 'reg_alpha': None, 'reg_lambda': None, 'sampling_method': None, 'scale_pos_weight': None, 'subsample': None, 'tree_method': 'auto', 'validate_parameters': None, 'verbosity': 0}
2025-08-27 23:31:43,354:INFO:Creating Dashboard logs
2025-08-27 23:31:43,357:INFO:Model: Light Gradient Boosting Machine
2025-08-27 23:31:43,415:INFO:Logged params: {'boosting_type': 'gbdt', 'class_weight': None, 'colsample_bytree': 1.0, 'importance_type': 'split', 'learning_rate': 0.1, 'max_depth': -1, 'min_child_samples': 20, 'min_child_weight': 0.001, 'min_split_gain': 0.0, 'n_estimators': 100, 'n_jobs': -1, 'num_leaves': 31, 'objective': None, 'random_state': 123, 'reg_alpha': 0.0, 'reg_lambda': 0.0, 'subsample': 1.0, 'subsample_for_bin': 200000, 'subsample_freq': 0}
2025-08-27 23:31:43,962:INFO:Creating Dashboard logs
2025-08-27 23:31:43,966:INFO:Model: Logistic Regression
2025-08-27 23:31:44,030:INFO:Logged params: {'C': 1.0, 'class_weight': None, 'dual': False, 'fit_intercept': True, 'intercept_scaling': 1, 'l1_ratio': None, 'max_iter': 1000, 'multi_class': 'auto', 'n_jobs': None, 'penalty': 'l2', 'random_state': 123, 'solver': 'lbfgs', 'tol': 0.0001, 'verbose': 0, 'warm_start': False}
2025-08-27 23:31:44,586:INFO:Creating Dashboard logs
2025-08-27 23:31:44,589:INFO:Model: Naive Bayes
2025-08-27 23:31:44,647:INFO:Logged params: {'priors': None, 'var_smoothing': 1e-09}
2025-08-27 23:31:45,152:INFO:Creating Dashboard logs
2025-08-27 23:31:45,154:INFO:Model: SVM - Linear Kernel
2025-08-27 23:31:45,211:INFO:Logged params: {'alpha': 0.0001, 'average': False, 'class_weight': None, 'early_stopping': False, 'epsilon': 0.1, 'eta0': 0.001, 'fit_intercept': True, 'l1_ratio': 0.15, 'learning_rate': 'optimal', 'loss': 'hinge', 'max_iter': 1000, 'n_iter_no_change': 5, 'n_jobs': -1, 'penalty': 'l2', 'power_t': 0.5, 'random_state': 123, 'shuffle': True, 'tol': 0.001, 'validation_fraction': 0.1, 'verbose': 0, 'warm_start': False}
2025-08-27 23:31:45,733:INFO:Creating Dashboard logs
2025-08-27 23:31:45,736:INFO:Model: Gradient Boosting Classifier
2025-08-27 23:31:45,795:INFO:Logged params: {'ccp_alpha': 0.0, 'criterion': 'friedman_mse', 'init': None, 'learning_rate': 0.1, 'loss': 'log_loss', 'max_depth': 3, 'max_features': None, 'max_leaf_nodes': None, 'min_impurity_decrease': 0.0, 'min_samples_leaf': 1, 'min_samples_split': 2, 'min_weight_fraction_leaf': 0.0, 'n_estimators': 100, 'n_iter_no_change': None, 'random_state': 123, 'subsample': 1.0, 'tol': 0.0001, 'validation_fraction': 0.1, 'verbose': 0, 'warm_start': False}
2025-08-27 23:31:46,320:INFO:Creating Dashboard logs
2025-08-27 23:31:46,323:INFO:Model: Extra Trees Classifier
2025-08-27 23:31:46,383:INFO:Logged params: {'bootstrap': False, 'ccp_alpha': 0.0, 'class_weight': None, 'criterion': 'gini', 'max_depth': None, 'max_features': 'sqrt', 'max_leaf_nodes': None, 'max_samples': None, 'min_impurity_decrease': 0.0, 'min_samples_leaf': 1, 'min_samples_split': 2, 'min_weight_fraction_leaf': 0.0, 'monotonic_cst': None, 'n_estimators': 100, 'n_jobs': -1, 'oob_score': False, 'random_state': 123, 'verbose': 0, 'warm_start': False}
2025-08-27 23:31:46,899:INFO:Creating Dashboard logs
2025-08-27 23:31:46,901:INFO:Model: Random Forest Classifier
2025-08-27 23:31:46,958:INFO:Logged params: {'bootstrap': True, 'ccp_alpha': 0.0, 'class_weight': None, 'criterion': 'gini', 'max_depth': None, 'max_features': 'sqrt', 'max_leaf_nodes': None, 'max_samples': None, 'min_impurity_decrease': 0.0, 'min_samples_leaf': 1, 'min_samples_split': 2, 'min_weight_fraction_leaf': 0.0, 'monotonic_cst': None, 'n_estimators': 100, 'n_jobs': -1, 'oob_score': False, 'random_state': 123, 'verbose': 0, 'warm_start': False}
2025-08-27 23:31:47,491:INFO:Creating Dashboard logs
2025-08-27 23:31:47,494:INFO:Model: K Neighbors Classifier
2025-08-27 23:31:47,554:INFO:Logged params: {'algorithm': 'auto', 'leaf_size': 30, 'metric': 'minkowski', 'metric_params': None, 'n_jobs': -1, 'n_neighbors': 5, 'p': 2, 'weights': 'uniform'}
2025-08-27 23:31:48,056:INFO:Creating Dashboard logs
2025-08-27 23:31:48,059:INFO:Model: CatBoost Classifier
2025-08-27 23:31:48,118:WARNING:Couldn't get params for model. Exception:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\loggers\dashboard_logger.py", line 78, in log_model
    params = params.get_all_params()
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\catboost\core.py", line 3504, in get_all_params
    raise CatBoostError("There is no trained model to use get_all_params(). Use fit() to train model. Then use this method.")
_catboost.CatBoostError: There is no trained model to use get_all_params(). Use fit() to train model. Then use this method.

2025-08-27 23:31:48,118:INFO:Logged params: {}
2025-08-27 23:31:48,607:INFO:Creating Dashboard logs
2025-08-27 23:31:48,610:INFO:Model: Decision Tree Classifier
2025-08-27 23:31:48,666:INFO:Logged params: {'ccp_alpha': 0.0, 'class_weight': None, 'criterion': 'gini', 'max_depth': None, 'max_features': None, 'max_leaf_nodes': None, 'min_impurity_decrease': 0.0, 'min_samples_leaf': 1, 'min_samples_split': 2, 'min_weight_fraction_leaf': 0.0, 'monotonic_cst': None, 'random_state': 123, 'splitter': 'best'}
2025-08-27 23:31:49,175:INFO:Creating Dashboard logs
2025-08-27 23:31:49,178:INFO:Model: Ada Boost Classifier
2025-08-27 23:31:49,233:INFO:Logged params: {'algorithm': 'SAMME.R', 'estimator': None, 'learning_rate': 1.0, 'n_estimators': 50, 'random_state': 123}
2025-08-27 23:31:49,741:INFO:Creating Dashboard logs
2025-08-27 23:31:49,744:INFO:Model: Dummy Classifier
2025-08-27 23:31:49,799:INFO:Logged params: {'constant': None, 'random_state': 123, 'strategy': 'prior'}
2025-08-27 23:31:50,309:INFO:_master_model_container: 16
2025-08-27 23:31:50,309:INFO:_display_container: 2
2025-08-27 23:31:50,310:INFO:LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001)
2025-08-27 23:31:50,310:INFO:compare_models() successfully completed......................................
2025-08-27 23:36:13,420:INFO:Initializing tune_model()
2025-08-27 23:36:13,420:INFO:tune_model(estimator=LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001), fold=None, round=4, n_iter=10, custom_grid=None, optimize=Accuracy, custom_scorer=None, search_library=scikit-learn, search_algorithm=None, early_stopping=False, early_stopping_max_iters=10, choose_better=True, fit_kwargs=None, groups=None, return_tuner=False, verbose=True, tuner_verbose=True, return_train_score=False, kwargs={}, self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>)
2025-08-27 23:36:13,420:INFO:Checking exceptions
2025-08-27 23:36:13,434:INFO:Copying training dataset
2025-08-27 23:36:13,437:INFO:Checking base model
2025-08-27 23:36:13,438:INFO:Base model : Linear Discriminant Analysis
2025-08-27 23:36:13,443:INFO:Declaring metric variables
2025-08-27 23:36:13,450:INFO:Defining Hyperparameters
2025-08-27 23:36:13,656:INFO:Tuning with n_jobs=-1
2025-08-27 23:36:13,656:INFO:Initializing RandomizedSearchCV
2025-08-27 23:36:13,995:INFO:best_params: {'actual_estimator__solver': 'eigen', 'actual_estimator__shrinkage': 0.01}
2025-08-27 23:36:13,995:INFO:Hyperparameter search completed
2025-08-27 23:36:13,995:INFO:SubProcess create_model() called ==================================
2025-08-27 23:36:13,995:INFO:Initializing create_model()
2025-08-27 23:36:13,996:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001), fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=True, probability_threshold=None, experiment_custom_tags=None, verbose=True, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x0000028AA5B6F400>, model_only=True, return_train_score=False, error_score=0.0, kwargs={'solver': 'eigen', 'shrinkage': 0.01})
2025-08-27 23:36:13,996:INFO:Checking exceptions
2025-08-27 23:36:13,996:INFO:Importing libraries
2025-08-27 23:36:13,996:INFO:Copying training dataset
2025-08-27 23:36:13,998:INFO:Defining folds
2025-08-27 23:36:13,998:INFO:Declaring metric variables
2025-08-27 23:36:14,001:INFO:Importing untrained model
2025-08-27 23:36:14,001:INFO:Declaring custom model
2025-08-27 23:36:14,004:INFO:Linear Discriminant Analysis Imported successfully
2025-08-27 23:36:14,009:INFO:Starting cross validation
2025-08-27 23:36:14,010:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2025-08-27 23:36:14,047:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:36:14,049:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,052:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,053:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:36:14,054:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:36:14,055:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,056:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,056:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,059:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,059:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:36:14,060:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:36:14,060:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:36:14,060:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,061:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,062:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,062:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,063:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:36:14,064:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,065:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,065:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,066:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,066:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,067:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:36:14,067:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,068:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,069:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,069:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,069:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:36:14,070:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,070:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,070:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,070:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:36:14,071:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,072:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,073:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,073:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,074:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,075:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,075:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,078:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,087:INFO:Calculating mean and std
2025-08-27 23:36:14,088:INFO:Creating metrics dataframe
2025-08-27 23:36:14,092:INFO:Finalizing model
2025-08-27 23:36:14,105:INFO:Uploading results into container
2025-08-27 23:36:14,105:INFO:Uploading model into container now
2025-08-27 23:36:14,106:INFO:_master_model_container: 17
2025-08-27 23:36:14,106:INFO:_display_container: 3
2025-08-27 23:36:14,106:INFO:LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=0.01, solver='eigen',
                           store_covariance=False, tol=0.0001)
2025-08-27 23:36:14,107:INFO:create_model() successfully completed......................................
2025-08-27 23:36:14,354:INFO:SubProcess create_model() end ==================================
2025-08-27 23:36:14,354:INFO:choose_better activated
2025-08-27 23:36:14,357:INFO:SubProcess create_model() called ==================================
2025-08-27 23:36:14,358:INFO:Initializing create_model()
2025-08-27 23:36:14,358:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001), fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=True, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=None, model_only=True, return_train_score=False, error_score=0.0, kwargs={})
2025-08-27 23:36:14,358:INFO:Checking exceptions
2025-08-27 23:36:14,359:INFO:Importing libraries
2025-08-27 23:36:14,359:INFO:Copying training dataset
2025-08-27 23:36:14,361:INFO:Defining folds
2025-08-27 23:36:14,361:INFO:Declaring metric variables
2025-08-27 23:36:14,361:INFO:Importing untrained model
2025-08-27 23:36:14,361:INFO:Declaring custom model
2025-08-27 23:36:14,362:INFO:Linear Discriminant Analysis Imported successfully
2025-08-27 23:36:14,362:INFO:Starting cross validation
2025-08-27 23:36:14,363:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2025-08-27 23:36:14,397:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:36:14,397:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:36:14,398:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:36:14,399:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,399:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,400:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,401:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:36:14,401:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:36:14,402:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,402:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,403:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,403:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,403:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,404:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:36:14,405:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,406:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,406:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,406:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,406:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,407:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:36:14,408:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,408:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:36:14,409:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,409:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,409:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,410:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:36:14,410:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,410:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,410:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py:204: FitFailedWarning: Metric 'make_scorer(roc_auc_score, response_method=('decision_function', 'predict_proba'), average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 196, in _score
    return super()._score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_scorer.py", line 350, in _score
    return self._sign * self._score_func(y_true, y_pred, **scoring_kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\pycaret\internal\metrics.py", line 144, in __call__
    return self.score_func(y_true, y_pred, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\utils\_param_validation.py", line 213, in wrapper
    return func(*args, **kwargs)
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 634, in roc_auc_score
    return _multiclass_roc_auc_score(
  File "C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_ranking.py", line 707, in _multiclass_roc_auc_score
    raise ValueError(
ValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes

  warnings.warn(

2025-08-27 23:36:14,412:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,412:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,412:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,414:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,415:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,415:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,416:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,416:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,418:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,418:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2025-08-27 23:36:14,428:INFO:Calculating mean and std
2025-08-27 23:36:14,428:INFO:Creating metrics dataframe
2025-08-27 23:36:14,430:INFO:Finalizing model
2025-08-27 23:36:14,438:INFO:Uploading results into container
2025-08-27 23:36:14,438:INFO:Uploading model into container now
2025-08-27 23:36:14,438:INFO:_master_model_container: 18
2025-08-27 23:36:14,438:INFO:_display_container: 4
2025-08-27 23:36:14,439:INFO:LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001)
2025-08-27 23:36:14,439:INFO:create_model() successfully completed......................................
2025-08-27 23:36:14,618:INFO:SubProcess create_model() end ==================================
2025-08-27 23:36:14,619:INFO:LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001) result for Accuracy is 0.9643
2025-08-27 23:36:14,619:INFO:LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=0.01, solver='eigen',
                           store_covariance=False, tol=0.0001) result for Accuracy is 0.9643
2025-08-27 23:36:14,619:INFO:LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001) is best model
2025-08-27 23:36:14,619:INFO:choose_better completed
2025-08-27 23:36:14,619:INFO:Original model was better than the tuned model, hence it will be returned. NOTE: The display metrics are for the tuned model (not the original one).
2025-08-27 23:36:14,620:INFO:Creating Dashboard logs
2025-08-27 23:36:14,622:INFO:Model: Linear Discriminant Analysis
2025-08-27 23:36:16,746:INFO:Logged params: {'covariance_estimator': None, 'n_components': None, 'priors': None, 'shrinkage': None, 'solver': 'svd', 'store_covariance': False, 'tol': 0.0001}
2025-08-27 23:36:16,984:INFO:Initializing predict_model()
2025-08-27 23:36:16,984:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=False, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x0000028AA56F0D30>)
2025-08-27 23:36:16,984:INFO:Checking exceptions
2025-08-27 23:36:16,984:INFO:Preloading libraries
2025-08-27 23:36:17,027:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.

2025-08-27 23:36:17,028:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.

2025-08-27 23:36:17,030:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.

2025-08-27 23:36:17,228:INFO:SubProcess plot_model() called ==================================
2025-08-27 23:36:17,228:INFO:Initializing plot_model()
2025-08-27 23:36:17,228:INFO:plot_model(plot=auc, fold=None, verbose=False, display=None, display_format=None, estimator=LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001), feature_name=None, fit_kwargs=None, groups=None, label=False, plot_kwargs=None, save=C:\Users\javie\AppData\Local\Temp\tmpije8xunq, scale=1, self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, system=False)
2025-08-27 23:36:17,228:INFO:Checking exceptions
2025-08-27 23:36:17,229:INFO:Preloading libraries
2025-08-27 23:36:17,229:INFO:Copying training dataset
2025-08-27 23:36:17,229:INFO:Plot type: auc
2025-08-27 23:36:17,294:INFO:Fitting Model
2025-08-27 23:36:17,294:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\base.py:493: UserWarning: X does not have valid feature names, but LinearDiscriminantAnalysis was fitted with feature names

2025-08-27 23:36:17,294:INFO:Scoring test/hold-out set
2025-08-27 23:36:17,310:INFO:Saving 'C:\Users\javie\AppData\Local\Temp\tmpije8xunq\AUC.png'
2025-08-27 23:36:17,476:INFO:Visual Rendered Successfully
2025-08-27 23:36:17,655:INFO:plot_model() successfully completed......................................
2025-08-27 23:36:17,674:INFO:Initializing plot_model()
2025-08-27 23:36:17,674:INFO:plot_model(plot=confusion_matrix, fold=None, verbose=False, display=None, display_format=None, estimator=LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001), feature_name=None, fit_kwargs=None, groups=None, label=False, plot_kwargs=None, save=C:\Users\javie\AppData\Local\Temp\tmpije8xunq, scale=1, self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, system=False)
2025-08-27 23:36:17,674:INFO:Checking exceptions
2025-08-27 23:36:17,675:INFO:Preloading libraries
2025-08-27 23:36:17,676:INFO:Copying training dataset
2025-08-27 23:36:17,676:INFO:Plot type: confusion_matrix
2025-08-27 23:36:17,740:INFO:Fitting Model
2025-08-27 23:36:17,740:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\base.py:493: UserWarning: X does not have valid feature names, but LinearDiscriminantAnalysis was fitted with feature names

2025-08-27 23:36:17,740:INFO:Scoring test/hold-out set
2025-08-27 23:36:17,757:INFO:Saving 'C:\Users\javie\AppData\Local\Temp\tmpije8xunq\Confusion Matrix.png'
2025-08-27 23:36:17,848:INFO:Visual Rendered Successfully
2025-08-27 23:36:18,026:INFO:plot_model() successfully completed......................................
2025-08-27 23:36:18,045:INFO:Initializing plot_model()
2025-08-27 23:36:18,045:INFO:plot_model(plot=feature, fold=None, verbose=False, display=None, display_format=None, estimator=LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001), feature_name=None, fit_kwargs=None, groups=None, label=False, plot_kwargs=None, save=C:\Users\javie\AppData\Local\Temp\tmpije8xunq, scale=1, self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, system=False)
2025-08-27 23:36:18,046:INFO:Checking exceptions
2025-08-27 23:36:18,047:INFO:Preloading libraries
2025-08-27 23:36:18,047:INFO:Copying training dataset
2025-08-27 23:36:18,047:INFO:Plot type: feature
2025-08-27 23:36:18,109:INFO:Saving 'C:\Users\javie\AppData\Local\Temp\tmpije8xunq\Feature Importance.png'
2025-08-27 23:36:18,191:INFO:Visual Rendered Successfully
2025-08-27 23:36:18,370:INFO:plot_model() successfully completed......................................
2025-08-27 23:36:18,389:INFO:SubProcess plot_model() end ==================================
2025-08-27 23:36:18,711:INFO:_master_model_container: 18
2025-08-27 23:36:18,711:INFO:_display_container: 3
2025-08-27 23:36:18,712:INFO:LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001)
2025-08-27 23:36:18,712:INFO:tune_model() successfully completed......................................
2025-08-27 23:36:23,400:INFO:Initializing finalize_model()
2025-08-27 23:36:23,400:INFO:finalize_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001), fit_kwargs=None, groups=None, model_only=False, experiment_custom_tags=None)
2025-08-27 23:36:23,401:INFO:Finalizing LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001)
2025-08-27 23:36:23,403:INFO:Initializing create_model()
2025-08-27 23:36:23,403:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=LinearDiscriminantAnalysis(covariance_estimator=None, n_components=None,
                           priors=None, shrinkage=None, solver='svd',
                           store_covariance=False, tol=0.0001), fold=None, round=4, cross_validation=False, predict=False, fit_kwargs={}, groups=None, refit=True, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=False, metrics=None, display=None, model_only=False, return_train_score=False, error_score=0.0, kwargs={})
2025-08-27 23:36:23,403:INFO:Checking exceptions
2025-08-27 23:36:23,404:INFO:Importing libraries
2025-08-27 23:36:23,404:INFO:Copying training dataset
2025-08-27 23:36:23,404:INFO:Defining folds
2025-08-27 23:36:23,405:INFO:Declaring metric variables
2025-08-27 23:36:23,405:INFO:Importing untrained model
2025-08-27 23:36:23,405:INFO:Declaring custom model
2025-08-27 23:36:23,405:INFO:Linear Discriminant Analysis Imported successfully
2025-08-27 23:36:23,406:INFO:Cross validation set to False
2025-08-27 23:36:23,406:INFO:Fitting Model
2025-08-27 23:36:23,418:INFO:Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(exclude=None, include=None,
                                               transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(exclude=None,
                                    include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer(add_indicator=False,
                                                              copy=True,
                                                              fill_value=None,
                                                              keep_empty...
                                                              missing_values=nan,
                                                              strategy='most_frequent'))),
                ('normalize',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=StandardScaler(copy=True,
                                                               with_mean=True,
                                                               with_std=True))),
                ('actual_estimator',
                 LinearDiscriminantAnalysis(covariance_estimator=None,
                                            n_components=None, priors=None,
                                            shrinkage=None, solver='svd',
                                            store_covariance=False,
                                            tol=0.0001))],
         verbose=False)
2025-08-27 23:36:23,418:INFO:create_model() successfully completed......................................
2025-08-27 23:36:23,603:INFO:Creating Dashboard logs
2025-08-27 23:36:23,604:INFO:Model: Linear Discriminant Analysis
2025-08-27 23:36:23,659:INFO:Logged params: {'covariance_estimator': None, 'n_components': None, 'priors': None, 'shrinkage': None, 'solver': 'svd', 'store_covariance': False, 'tol': 0.0001}
2025-08-27 23:36:23,810:INFO:SubProcess plot_model() called ==================================
2025-08-27 23:36:23,814:INFO:Initializing plot_model()
2025-08-27 23:36:23,814:INFO:plot_model(plot=auc, fold=None, verbose=False, display=None, display_format=None, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(exclude=None, include=None,
                                               transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(exclude=None,
                                    include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer(add_indicator=False,
                                                              copy=True,
                                                              fill_value=None,
                                                              keep_empty...
                                                              missing_values=nan,
                                                              strategy='most_frequent'))),
                ('normalize',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=StandardScaler(copy=True,
                                                               with_mean=True,
                                                               with_std=True))),
                ('actual_estimator',
                 LinearDiscriminantAnalysis(covariance_estimator=None,
                                            n_components=None, priors=None,
                                            shrinkage=None, solver='svd',
                                            store_covariance=False,
                                            tol=0.0001))],
         verbose=False), feature_name=None, fit_kwargs=None, groups=None, label=False, plot_kwargs=None, save=C:\Users\javie\AppData\Local\Temp\tmpbg6ekg64, scale=1, self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, system=False)
2025-08-27 23:36:23,815:INFO:Checking exceptions
2025-08-27 23:36:23,816:INFO:Preloading libraries
2025-08-27 23:36:23,816:INFO:Copying training dataset
2025-08-27 23:36:23,816:INFO:Plot type: auc
2025-08-27 23:36:23,883:INFO:Fitting Model
2025-08-27 23:36:23,884:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\base.py:493: UserWarning: X does not have valid feature names, but LinearDiscriminantAnalysis was fitted with feature names

2025-08-27 23:36:23,884:INFO:Scoring test/hold-out set
2025-08-27 23:36:23,900:INFO:Saving 'C:\Users\javie\AppData\Local\Temp\tmpbg6ekg64\AUC.png'
2025-08-27 23:36:24,070:INFO:Visual Rendered Successfully
2025-08-27 23:36:24,254:INFO:plot_model() successfully completed......................................
2025-08-27 23:36:24,292:INFO:Initializing plot_model()
2025-08-27 23:36:24,292:INFO:plot_model(plot=confusion_matrix, fold=None, verbose=False, display=None, display_format=None, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(exclude=None, include=None,
                                               transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(exclude=None,
                                    include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer(add_indicator=False,
                                                              copy=True,
                                                              fill_value=None,
                                                              keep_empty...
                                                              missing_values=nan,
                                                              strategy='most_frequent'))),
                ('normalize',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=StandardScaler(copy=True,
                                                               with_mean=True,
                                                               with_std=True))),
                ('actual_estimator',
                 LinearDiscriminantAnalysis(covariance_estimator=None,
                                            n_components=None, priors=None,
                                            shrinkage=None, solver='svd',
                                            store_covariance=False,
                                            tol=0.0001))],
         verbose=False), feature_name=None, fit_kwargs=None, groups=None, label=False, plot_kwargs=None, save=C:\Users\javie\AppData\Local\Temp\tmpbg6ekg64, scale=1, self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, system=False)
2025-08-27 23:36:24,292:INFO:Checking exceptions
2025-08-27 23:36:24,293:INFO:Preloading libraries
2025-08-27 23:36:24,293:INFO:Copying training dataset
2025-08-27 23:36:24,294:INFO:Plot type: confusion_matrix
2025-08-27 23:36:24,362:INFO:Fitting Model
2025-08-27 23:36:24,362:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\base.py:493: UserWarning: X does not have valid feature names, but LinearDiscriminantAnalysis was fitted with feature names

2025-08-27 23:36:24,362:INFO:Scoring test/hold-out set
2025-08-27 23:36:24,378:INFO:Saving 'C:\Users\javie\AppData\Local\Temp\tmpbg6ekg64\Confusion Matrix.png'
2025-08-27 23:36:24,470:INFO:Visual Rendered Successfully
2025-08-27 23:36:24,653:INFO:plot_model() successfully completed......................................
2025-08-27 23:36:24,677:INFO:Initializing plot_model()
2025-08-27 23:36:24,677:INFO:plot_model(plot=feature, fold=None, verbose=False, display=None, display_format=None, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(exclude=None, include=None,
                                               transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(exclude=None,
                                    include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer(add_indicator=False,
                                                              copy=True,
                                                              fill_value=None,
                                                              keep_empty...
                                                              missing_values=nan,
                                                              strategy='most_frequent'))),
                ('normalize',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=StandardScaler(copy=True,
                                                               with_mean=True,
                                                               with_std=True))),
                ('actual_estimator',
                 LinearDiscriminantAnalysis(covariance_estimator=None,
                                            n_components=None, priors=None,
                                            shrinkage=None, solver='svd',
                                            store_covariance=False,
                                            tol=0.0001))],
         verbose=False), feature_name=None, fit_kwargs=None, groups=None, label=False, plot_kwargs=None, save=C:\Users\javie\AppData\Local\Temp\tmpbg6ekg64, scale=1, self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, system=False)
2025-08-27 23:36:24,678:INFO:Checking exceptions
2025-08-27 23:36:24,679:INFO:Preloading libraries
2025-08-27 23:36:24,679:INFO:Copying training dataset
2025-08-27 23:36:24,679:INFO:Plot type: feature
2025-08-27 23:36:24,745:INFO:Saving 'C:\Users\javie\AppData\Local\Temp\tmpbg6ekg64\Feature Importance.png'
2025-08-27 23:36:24,838:INFO:Visual Rendered Successfully
2025-08-27 23:36:25,031:INFO:plot_model() successfully completed......................................
2025-08-27 23:36:25,052:INFO:SubProcess plot_model() end ==================================
2025-08-27 23:36:25,396:INFO:_master_model_container: 18
2025-08-27 23:36:25,396:INFO:_display_container: 3
2025-08-27 23:36:25,400:INFO:Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(exclude=None, include=None,
                                               transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(exclude=None,
                                    include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer(add_indicator=False,
                                                              copy=True,
                                                              fill_value=None,
                                                              keep_empty...
                                                              missing_values=nan,
                                                              strategy='most_frequent'))),
                ('normalize',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=StandardScaler(copy=True,
                                                               with_mean=True,
                                                               with_std=True))),
                ('actual_estimator',
                 LinearDiscriminantAnalysis(covariance_estimator=None,
                                            n_components=None, priors=None,
                                            shrinkage=None, solver='svd',
                                            store_covariance=False,
                                            tol=0.0001))],
         verbose=False)
2025-08-27 23:36:25,401:INFO:finalize_model() successfully completed......................................
2025-08-27 23:36:35,320:INFO:Initializing plot_model()
2025-08-27 23:36:35,320:INFO:plot_model(plot=confusion_matrix, fold=None, verbose=True, display=None, display_format=None, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(exclude=None, include=None,
                                               transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(exclude=None,
                                    include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer(add_indicator=False,
                                                              copy=True,
                                                              fill_value=None,
                                                              keep_empty...
                                                              missing_values=nan,
                                                              strategy='most_frequent'))),
                ('normalize',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=StandardScaler(copy=True,
                                                               with_mean=True,
                                                               with_std=True))),
                ('actual_estimator',
                 LinearDiscriminantAnalysis(covariance_estimator=None,
                                            n_components=None, priors=None,
                                            shrinkage=None, solver='svd',
                                            store_covariance=False,
                                            tol=0.0001))],
         verbose=False), feature_name=None, fit_kwargs=None, groups=None, label=False, plot_kwargs=None, save=False, scale=1, self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, system=True)
2025-08-27 23:36:35,320:INFO:Checking exceptions
2025-08-27 23:36:35,323:INFO:Preloading libraries
2025-08-27 23:36:35,323:INFO:Copying training dataset
2025-08-27 23:36:35,323:INFO:Plot type: confusion_matrix
2025-08-27 23:36:35,397:INFO:Fitting Model
2025-08-27 23:36:35,397:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\base.py:493: UserWarning: X does not have valid feature names, but LinearDiscriminantAnalysis was fitted with feature names

2025-08-27 23:36:35,397:INFO:Scoring test/hold-out set
2025-08-27 23:36:35,487:INFO:Visual Rendered Successfully
2025-08-27 23:36:35,663:INFO:plot_model() successfully completed......................................
2025-08-27 23:36:38,233:INFO:Initializing plot_model()
2025-08-27 23:36:38,233:INFO:plot_model(plot=class_report, fold=None, verbose=True, display=None, display_format=None, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(exclude=None, include=None,
                                               transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(exclude=None,
                                    include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer(add_indicator=False,
                                                              copy=True,
                                                              fill_value=None,
                                                              keep_empty...
                                                              missing_values=nan,
                                                              strategy='most_frequent'))),
                ('normalize',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=StandardScaler(copy=True,
                                                               with_mean=True,
                                                               with_std=True))),
                ('actual_estimator',
                 LinearDiscriminantAnalysis(covariance_estimator=None,
                                            n_components=None, priors=None,
                                            shrinkage=None, solver='svd',
                                            store_covariance=False,
                                            tol=0.0001))],
         verbose=False), feature_name=None, fit_kwargs=None, groups=None, label=False, plot_kwargs=None, save=False, scale=1, self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, system=True)
2025-08-27 23:36:38,233:INFO:Checking exceptions
2025-08-27 23:36:38,236:INFO:Preloading libraries
2025-08-27 23:36:38,236:INFO:Copying training dataset
2025-08-27 23:36:38,236:INFO:Plot type: class_report
2025-08-27 23:36:38,311:INFO:Fitting Model
2025-08-27 23:36:38,311:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\base.py:493: UserWarning: X does not have valid feature names, but LinearDiscriminantAnalysis was fitted with feature names

2025-08-27 23:36:38,311:INFO:Scoring test/hold-out set
2025-08-27 23:36:38,471:INFO:Visual Rendered Successfully
2025-08-27 23:36:38,652:INFO:plot_model() successfully completed......................................
2025-08-27 23:36:40,435:INFO:Initializing plot_model()
2025-08-27 23:36:40,435:INFO:plot_model(plot=feature, fold=None, verbose=True, display=None, display_format=None, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(exclude=None, include=None,
                                               transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(exclude=None,
                                    include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer(add_indicator=False,
                                                              copy=True,
                                                              fill_value=None,
                                                              keep_empty...
                                                              missing_values=nan,
                                                              strategy='most_frequent'))),
                ('normalize',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=StandardScaler(copy=True,
                                                               with_mean=True,
                                                               with_std=True))),
                ('actual_estimator',
                 LinearDiscriminantAnalysis(covariance_estimator=None,
                                            n_components=None, priors=None,
                                            shrinkage=None, solver='svd',
                                            store_covariance=False,
                                            tol=0.0001))],
         verbose=False), feature_name=None, fit_kwargs=None, groups=None, label=False, plot_kwargs=None, save=False, scale=1, self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, system=True)
2025-08-27 23:36:40,435:INFO:Checking exceptions
2025-08-27 23:36:40,438:INFO:Preloading libraries
2025-08-27 23:36:40,438:INFO:Copying training dataset
2025-08-27 23:36:40,439:INFO:Plot type: feature
2025-08-27 23:36:40,574:INFO:Visual Rendered Successfully
2025-08-27 23:36:40,760:INFO:plot_model() successfully completed......................................
2025-08-27 23:36:41,699:INFO:Initializing predict_model()
2025-08-27 23:36:41,699:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(exclude=None, include=None,
                                               transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(exclude=None,
                                    include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer(add_indicator=False,
                                                              copy=True,
                                                              fill_value=None,
                                                              keep_empty...
                                                              missing_values=nan,
                                                              strategy='most_frequent'))),
                ('normalize',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=StandardScaler(copy=True,
                                                               with_mean=True,
                                                               with_std=True))),
                ('actual_estimator',
                 LinearDiscriminantAnalysis(covariance_estimator=None,
                                            n_components=None, priors=None,
                                            shrinkage=None, solver='svd',
                                            store_covariance=False,
                                            tol=0.0001))],
         verbose=False), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x0000028AA5B95480>)
2025-08-27 23:36:41,699:INFO:Checking exceptions
2025-08-27 23:36:41,699:INFO:Preloading libraries
2025-08-27 23:36:41,744:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.

2025-08-27 23:36:41,746:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.

2025-08-27 23:36:41,747:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.

2025-08-27 23:36:52,309:INFO:Initializing predict_model()
2025-08-27 23:36:52,309:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000028A9DAB4F70>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(exclude=None, include=None,
                                               transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(exclude=None,
                                    include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer(add_indicator=False,
                                                              copy=True,
                                                              fill_value=None,
                                                              keep_empty...
                                                              missing_values=nan,
                                                              strategy='most_frequent'))),
                ('normalize',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=StandardScaler(copy=True,
                                                               with_mean=True,
                                                               with_std=True))),
                ('actual_estimator',
                 LinearDiscriminantAnalysis(covariance_estimator=None,
                                            n_components=None, priors=None,
                                            shrinkage=None, solver='svd',
                                            store_covariance=False,
                                            tol=0.0001))],
         verbose=False), probability_threshold=None, encoded_labels=False, raw_score=False, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x0000028A9E2ACB80>)
2025-08-27 23:36:52,309:INFO:Checking exceptions
2025-08-27 23:36:52,309:INFO:Preloading libraries
2025-08-27 23:36:52,362:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.

2025-08-27 23:36:52,364:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.

2025-08-27 23:36:52,365:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\sklearn\metrics\_classification.py:1561: UserWarning: Note that pos_label (set to 3) is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.

2025-08-27 23:36:55,025:INFO:Initializing save_model()
2025-08-27 23:36:55,025:INFO:save_model(model=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(exclude=None, include=None,
                                               transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(exclude=None,
                                    include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer(add_indicator=False,
                                                              copy=True,
                                                              fill_value=None,
                                                              keep_empty...
                                                              missing_values=nan,
                                                              strategy='most_frequent'))),
                ('normalize',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=StandardScaler(copy=True,
                                                               with_mean=True,
                                                               with_std=True))),
                ('actual_estimator',
                 LinearDiscriminantAnalysis(covariance_estimator=None,
                                            n_components=None, priors=None,
                                            shrinkage=None, solver='svd',
                                            store_covariance=False,
                                            tol=0.0001))],
         verbose=False), model_name=wheat_seeds_best, prep_pipe_=Pipeline(memory=FastMemory(location=C:\Users\javie\AppData\Local\Temp\joblib),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(exclude=None, include=None,
                                               transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(exclude=None,
                                    include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer(add_indicator=Fa...
                ('categorical_imputer',
                 TransformerWrapper(exclude=None, include=[],
                                    transformer=SimpleImputer(add_indicator=False,
                                                              copy=True,
                                                              fill_value=None,
                                                              keep_empty_features=False,
                                                              missing_values=nan,
                                                              strategy='most_frequent'))),
                ('normalize',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=StandardScaler(copy=True,
                                                               with_mean=True,
                                                               with_std=True)))],
         verbose=False), verbose=True, use_case=MLUsecase.CLASSIFICATION, kwargs={})
2025-08-27 23:36:55,025:INFO:Adding model into prep_pipe
2025-08-27 23:36:55,025:WARNING:Only Model saved as it was a pipeline.
2025-08-27 23:36:55,029:INFO:wheat_seeds_best.pkl saved in current working directory
2025-08-27 23:36:55,033:INFO:Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(exclude=None, include=None,
                                               transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(exclude=None,
                                    include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer(add_indicator=False,
                                                              copy=True,
                                                              fill_value=None,
                                                              keep_empty...
                                                              missing_values=nan,
                                                              strategy='most_frequent'))),
                ('normalize',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=StandardScaler(copy=True,
                                                               with_mean=True,
                                                               with_std=True))),
                ('actual_estimator',
                 LinearDiscriminantAnalysis(covariance_estimator=None,
                                            n_components=None, priors=None,
                                            shrinkage=None, solver='svd',
                                            store_covariance=False,
                                            tol=0.0001))],
         verbose=False)
2025-08-27 23:36:55,033:INFO:save_model() successfully completed......................................
2025-08-27 23:37:55,620:INFO:Initializing predict_model()
2025-08-27 23:37:55,620:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218E1CC1270>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218A96FD990>)
2025-08-27 23:37:55,620:INFO:Checking exceptions
2025-08-27 23:37:55,620:INFO:Preloading libraries
2025-08-27 23:37:55,622:INFO:Set up data.
2025-08-27 23:37:55,624:INFO:Set up index.
2025-08-27 23:39:03,091:INFO:Initializing predict_model()
2025-08-27 23:39:03,092:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218A969BC70>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218A96AEE60>)
2025-08-27 23:39:03,092:INFO:Checking exceptions
2025-08-27 23:39:03,092:INFO:Preloading libraries
2025-08-27 23:39:03,092:INFO:Set up data.
2025-08-27 23:39:03,095:INFO:Set up index.
2025-08-27 23:39:24,556:INFO:Initializing predict_model()
2025-08-27 23:39:24,556:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218A8608AC0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218A87FBBE0>)
2025-08-27 23:39:24,556:INFO:Checking exceptions
2025-08-27 23:39:24,556:INFO:Preloading libraries
2025-08-27 23:39:24,556:INFO:Set up data.
2025-08-27 23:39:24,559:INFO:Set up index.
2025-08-27 23:39:31,134:INFO:Initializing predict_model()
2025-08-27 23:39:31,134:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218A86F4100>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218A86BA4D0>)
2025-08-27 23:39:31,134:INFO:Checking exceptions
2025-08-27 23:39:31,134:INFO:Preloading libraries
2025-08-27 23:39:31,134:INFO:Set up data.
2025-08-27 23:39:31,137:INFO:Set up index.
2025-08-27 23:39:49,011:INFO:Initializing predict_model()
2025-08-27 23:39:49,011:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218A86F5EA0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218A96FEB00>)
2025-08-27 23:39:49,011:INFO:Checking exceptions
2025-08-27 23:39:49,011:INFO:Preloading libraries
2025-08-27 23:39:49,012:INFO:Set up data.
2025-08-27 23:39:49,015:INFO:Set up index.
2025-08-27 23:39:50,322:INFO:Initializing predict_model()
2025-08-27 23:39:50,323:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000002188254E1A0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218E1C15E10>)
2025-08-27 23:39:50,323:INFO:Checking exceptions
2025-08-27 23:39:50,323:INFO:Preloading libraries
2025-08-27 23:39:50,323:INFO:Set up data.
2025-08-27 23:39:50,325:INFO:Set up index.
2025-08-27 23:39:51,792:INFO:Initializing predict_model()
2025-08-27 23:39:51,793:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218A89654E0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218A86BBD00>)
2025-08-27 23:39:51,793:INFO:Checking exceptions
2025-08-27 23:39:51,793:INFO:Preloading libraries
2025-08-27 23:39:51,793:INFO:Set up data.
2025-08-27 23:39:51,796:INFO:Set up index.
2025-08-27 23:39:52,918:INFO:Initializing predict_model()
2025-08-27 23:39:52,919:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218A969BDF0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218A86B9EA0>)
2025-08-27 23:39:52,919:INFO:Checking exceptions
2025-08-27 23:39:52,919:INFO:Preloading libraries
2025-08-27 23:39:52,919:INFO:Set up data.
2025-08-27 23:39:52,921:INFO:Set up index.
2025-08-27 23:39:53,703:INFO:Initializing predict_model()
2025-08-27 23:39:53,703:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218A86F6950>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218A86B96C0>)
2025-08-27 23:39:53,703:INFO:Checking exceptions
2025-08-27 23:39:53,703:INFO:Preloading libraries
2025-08-27 23:39:53,704:INFO:Set up data.
2025-08-27 23:39:53,706:INFO:Set up index.
2025-08-27 23:39:53,718:INFO:Initializing predict_model()
2025-08-27 23:39:53,718:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000218A96C9C60>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Area', 'Perimeter', 'Compactness',
                                             'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', RidgeClassifier(random_state=123))]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x00000218A914EB90>)
2025-08-27 23:39:53,718:INFO:Checking exceptions
2025-08-27 23:39:53,719:INFO:Preloading libraries
2025-08-27 23:39:53,719:INFO:Set up data.
2025-08-27 23:39:53,721:INFO:Set up index.
2025-08-27 23:47:17,673:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-27 23:47:17,673:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-27 23:47:17,673:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-27 23:47:17,673:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-27 23:47:18,743:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\mlflow\protos\service_pb2.py:11: UserWarning: google.protobuf.service module is deprecated. RPC implementations should provide code generator plugins which generate code specific to the RPC implementation. service.py will be removed in Jan 2025
  from google.protobuf import service as _service

2025-08-27 23:47:20,653:INFO:Initializing load_model()
2025-08-27 23:47:20,653:INFO:load_model(model_name=models/wheat_seeds_best, platform=None, authentication=None, verbose=True)
2025-08-27 23:47:24,916:INFO:Initializing predict_model()
2025-08-27 23:47:24,916:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846AAD0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB57027AC0>)
2025-08-27 23:47:24,916:INFO:Checking exceptions
2025-08-27 23:47:24,916:INFO:Preloading libraries
2025-08-27 23:47:24,916:INFO:Set up data.
2025-08-27 23:47:24,919:INFO:Set up index.
2025-08-27 23:47:31,891:INFO:Initializing predict_model()
2025-08-27 23:47:31,891:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57471B70>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB10BD9870>)
2025-08-27 23:47:31,891:INFO:Checking exceptions
2025-08-27 23:47:31,891:INFO:Preloading libraries
2025-08-27 23:47:31,891:INFO:Set up data.
2025-08-27 23:47:31,893:INFO:Set up index.
2025-08-27 23:47:39,805:INFO:Initializing predict_model()
2025-08-27 23:47:39,805:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB584D4E50>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB584E5BD0>)
2025-08-27 23:47:39,805:INFO:Checking exceptions
2025-08-27 23:47:39,806:INFO:Preloading libraries
2025-08-27 23:47:39,806:INFO:Set up data.
2025-08-27 23:47:39,809:INFO:Set up index.
2025-08-27 23:47:39,930:INFO:Initializing predict_model()
2025-08-27 23:47:39,930:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB10BE9390>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB57027AC0>)
2025-08-27 23:47:39,931:INFO:Checking exceptions
2025-08-27 23:47:39,931:INFO:Preloading libraries
2025-08-27 23:47:39,931:INFO:Set up data.
2025-08-27 23:47:39,933:INFO:Set up index.
2025-08-27 23:48:42,446:INFO:Initializing predict_model()
2025-08-27 23:48:42,446:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57521510>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB584E63B0>)
2025-08-27 23:48:42,446:INFO:Checking exceptions
2025-08-27 23:48:42,447:INFO:Preloading libraries
2025-08-27 23:48:42,447:INFO:Set up data.
2025-08-27 23:48:42,450:INFO:Set up index.
2025-08-27 23:48:44,558:INFO:Initializing predict_model()
2025-08-27 23:48:44,558:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846BF40>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB584E6950>)
2025-08-27 23:48:44,559:INFO:Checking exceptions
2025-08-27 23:48:44,559:INFO:Preloading libraries
2025-08-27 23:48:44,559:INFO:Set up data.
2025-08-27 23:48:44,561:INFO:Set up index.
2025-08-27 23:48:46,044:INFO:Initializing predict_model()
2025-08-27 23:48:46,044:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846A680>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB5838F9A0>)
2025-08-27 23:48:46,044:INFO:Checking exceptions
2025-08-27 23:48:46,045:INFO:Preloading libraries
2025-08-27 23:48:46,045:INFO:Set up data.
2025-08-27 23:48:46,048:INFO:Set up index.
2025-08-27 23:48:46,960:INFO:Initializing predict_model()
2025-08-27 23:48:46,960:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57473D90>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB584E5AB0>)
2025-08-27 23:48:46,960:INFO:Checking exceptions
2025-08-27 23:48:46,960:INFO:Preloading libraries
2025-08-27 23:48:46,961:INFO:Set up data.
2025-08-27 23:48:46,963:INFO:Set up index.
2025-08-27 23:48:47,849:INFO:Initializing predict_model()
2025-08-27 23:48:47,849:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB10BE92A0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB584E5A20>)
2025-08-27 23:48:47,849:INFO:Checking exceptions
2025-08-27 23:48:47,849:INFO:Preloading libraries
2025-08-27 23:48:47,850:INFO:Set up data.
2025-08-27 23:48:47,852:INFO:Set up index.
2025-08-27 23:48:50,830:INFO:Initializing predict_model()
2025-08-27 23:48:50,830:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846B850>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB584E6170>)
2025-08-27 23:48:50,830:INFO:Checking exceptions
2025-08-27 23:48:50,830:INFO:Preloading libraries
2025-08-27 23:48:50,831:INFO:Set up data.
2025-08-27 23:48:50,834:INFO:Set up index.
2025-08-27 23:48:59,359:INFO:Initializing predict_model()
2025-08-27 23:48:59,360:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846BEE0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB584E6DD0>)
2025-08-27 23:48:59,360:INFO:Checking exceptions
2025-08-27 23:48:59,360:INFO:Preloading libraries
2025-08-27 23:48:59,360:INFO:Set up data.
2025-08-27 23:48:59,362:INFO:Set up index.
2025-08-27 23:48:59,652:INFO:Initializing predict_model()
2025-08-27 23:48:59,652:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846A650>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB10BD9870>)
2025-08-27 23:48:59,652:INFO:Checking exceptions
2025-08-27 23:48:59,652:INFO:Preloading libraries
2025-08-27 23:48:59,652:INFO:Set up data.
2025-08-27 23:48:59,654:INFO:Set up index.
2025-08-27 23:49:02,951:INFO:Initializing predict_model()
2025-08-27 23:49:02,951:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846BA60>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB584E5990>)
2025-08-27 23:49:02,951:INFO:Checking exceptions
2025-08-27 23:49:02,951:INFO:Preloading libraries
2025-08-27 23:49:02,951:INFO:Set up data.
2025-08-27 23:49:02,954:INFO:Set up index.
2025-08-27 23:49:03,190:INFO:Initializing predict_model()
2025-08-27 23:49:03,190:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB584D7100>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB584E6C20>)
2025-08-27 23:49:03,190:INFO:Checking exceptions
2025-08-27 23:49:03,190:INFO:Preloading libraries
2025-08-27 23:49:03,191:INFO:Set up data.
2025-08-27 23:49:03,193:INFO:Set up index.
2025-08-27 23:49:03,313:INFO:Initializing predict_model()
2025-08-27 23:49:03,313:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57471840>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB5838F9A0>)
2025-08-27 23:49:03,313:INFO:Checking exceptions
2025-08-27 23:49:03,313:INFO:Preloading libraries
2025-08-27 23:49:03,314:INFO:Set up data.
2025-08-27 23:49:03,316:INFO:Set up index.
2025-08-27 23:49:05,189:INFO:Initializing predict_model()
2025-08-27 23:49:05,189:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846A680>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB574FE170>)
2025-08-27 23:49:05,189:INFO:Checking exceptions
2025-08-27 23:49:05,189:INFO:Preloading libraries
2025-08-27 23:49:05,190:INFO:Set up data.
2025-08-27 23:49:05,191:INFO:Set up index.
2025-08-27 23:49:06,232:INFO:Initializing predict_model()
2025-08-27 23:49:06,232:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846A1D0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB584E5BD0>)
2025-08-27 23:49:06,232:INFO:Checking exceptions
2025-08-27 23:49:06,232:INFO:Preloading libraries
2025-08-27 23:49:06,233:INFO:Set up data.
2025-08-27 23:49:06,236:INFO:Set up index.
2025-08-27 23:49:08,801:INFO:Initializing predict_model()
2025-08-27 23:49:08,801:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57705F90>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB5838F9A0>)
2025-08-27 23:49:08,801:INFO:Checking exceptions
2025-08-27 23:49:08,801:INFO:Preloading libraries
2025-08-27 23:49:08,802:INFO:Set up data.
2025-08-27 23:49:08,804:INFO:Set up index.
2025-08-27 23:49:09,879:INFO:Initializing predict_model()
2025-08-27 23:49:09,879:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846B850>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB584E6200>)
2025-08-27 23:49:09,880:INFO:Checking exceptions
2025-08-27 23:49:09,880:INFO:Preloading libraries
2025-08-27 23:49:09,880:INFO:Set up data.
2025-08-27 23:49:09,884:INFO:Set up index.
2025-08-27 23:49:10,352:INFO:Initializing predict_model()
2025-08-27 23:49:10,353:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846B8B0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB584E6830>)
2025-08-27 23:49:10,353:INFO:Checking exceptions
2025-08-27 23:49:10,353:INFO:Preloading libraries
2025-08-27 23:49:10,353:INFO:Set up data.
2025-08-27 23:49:10,355:INFO:Set up index.
2025-08-27 23:49:10,900:INFO:Initializing predict_model()
2025-08-27 23:49:10,900:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB10C52EF0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB584E6EF0>)
2025-08-27 23:49:10,901:INFO:Checking exceptions
2025-08-27 23:49:10,901:INFO:Preloading libraries
2025-08-27 23:49:10,901:INFO:Set up data.
2025-08-27 23:49:10,905:INFO:Set up index.
2025-08-27 23:49:11,226:INFO:Initializing predict_model()
2025-08-27 23:49:11,226:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB58469F30>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB584E6B90>)
2025-08-27 23:49:11,227:INFO:Checking exceptions
2025-08-27 23:49:11,227:INFO:Preloading libraries
2025-08-27 23:49:11,227:INFO:Set up data.
2025-08-27 23:49:11,229:INFO:Set up index.
2025-08-27 23:49:12,187:INFO:Initializing predict_model()
2025-08-27 23:49:12,187:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB575216F0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB584E6B90>)
2025-08-27 23:49:12,187:INFO:Checking exceptions
2025-08-27 23:49:12,187:INFO:Preloading libraries
2025-08-27 23:49:12,188:INFO:Set up data.
2025-08-27 23:49:12,190:INFO:Set up index.
2025-08-27 23:49:12,803:INFO:Initializing predict_model()
2025-08-27 23:49:12,803:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846BF40>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB584E6200>)
2025-08-27 23:49:12,803:INFO:Checking exceptions
2025-08-27 23:49:12,804:INFO:Preloading libraries
2025-08-27 23:49:12,804:INFO:Set up data.
2025-08-27 23:49:12,807:INFO:Set up index.
2025-08-27 23:49:13,263:INFO:Initializing predict_model()
2025-08-27 23:49:13,263:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846BA30>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB584E6680>)
2025-08-27 23:49:13,264:INFO:Checking exceptions
2025-08-27 23:49:13,264:INFO:Preloading libraries
2025-08-27 23:49:13,264:INFO:Set up data.
2025-08-27 23:49:13,269:INFO:Set up index.
2025-08-27 23:52:10,013:INFO:Initializing predict_model()
2025-08-27 23:52:10,014:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57521840>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB584E5360>)
2025-08-27 23:52:10,014:INFO:Checking exceptions
2025-08-27 23:52:10,014:INFO:Preloading libraries
2025-08-27 23:52:10,015:INFO:Set up data.
2025-08-27 23:52:10,018:INFO:Set up index.
2025-08-27 23:52:17,622:INFO:Initializing predict_model()
2025-08-27 23:52:17,622:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846A080>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB584E5990>)
2025-08-27 23:52:17,622:INFO:Checking exceptions
2025-08-27 23:52:17,623:INFO:Preloading libraries
2025-08-27 23:52:17,623:INFO:Set up data.
2025-08-27 23:52:17,627:INFO:Set up index.
2025-08-27 23:52:18,262:INFO:Initializing predict_model()
2025-08-27 23:52:18,263:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846B250>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB584E63B0>)
2025-08-27 23:52:18,263:INFO:Checking exceptions
2025-08-27 23:52:18,263:INFO:Preloading libraries
2025-08-27 23:52:18,264:INFO:Set up data.
2025-08-27 23:52:18,268:INFO:Set up index.
2025-08-27 23:53:57,543:INFO:Initializing predict_model()
2025-08-27 23:53:57,543:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57471390>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB57436A70>)
2025-08-27 23:53:57,544:INFO:Checking exceptions
2025-08-27 23:53:57,544:INFO:Preloading libraries
2025-08-27 23:53:57,544:INFO:Set up data.
2025-08-27 23:53:57,547:INFO:Set up index.
2025-08-27 23:53:57,686:INFO:Initializing predict_model()
2025-08-27 23:53:57,686:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57521450>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB57436E60>)
2025-08-27 23:53:57,686:INFO:Checking exceptions
2025-08-27 23:53:57,686:INFO:Preloading libraries
2025-08-27 23:53:57,687:INFO:Set up data.
2025-08-27 23:53:57,689:INFO:Set up index.
2025-08-27 23:55:12,802:INFO:Initializing predict_model()
2025-08-27 23:55:12,802:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57094040>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB584E6B00>)
2025-08-27 23:55:12,802:INFO:Checking exceptions
2025-08-27 23:55:12,802:INFO:Preloading libraries
2025-08-27 23:55:12,803:INFO:Set up data.
2025-08-27 23:55:12,805:INFO:Set up index.
2025-08-27 23:55:15,119:INFO:Initializing predict_model()
2025-08-27 23:55:15,119:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5859EEC0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB5838F9A0>)
2025-08-27 23:55:15,119:INFO:Checking exceptions
2025-08-27 23:55:15,119:INFO:Preloading libraries
2025-08-27 23:55:15,120:INFO:Set up data.
2025-08-27 23:55:15,122:INFO:Set up index.
2025-08-27 23:55:15,252:INFO:Initializing predict_model()
2025-08-27 23:55:15,253:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB10C52EF0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB10C64C10>)
2025-08-27 23:55:15,253:INFO:Checking exceptions
2025-08-27 23:55:15,253:INFO:Preloading libraries
2025-08-27 23:55:15,253:INFO:Set up data.
2025-08-27 23:55:15,256:INFO:Set up index.
2025-08-28 00:00:51,863:INFO:Initializing predict_model()
2025-08-28 00:00:51,863:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5859F010>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB573E1FC0>)
2025-08-28 00:00:51,863:INFO:Checking exceptions
2025-08-28 00:00:51,864:INFO:Preloading libraries
2025-08-28 00:00:51,864:INFO:Set up data.
2025-08-28 00:00:51,868:INFO:Set up index.
2025-08-28 00:00:52,027:INFO:Initializing predict_model()
2025-08-28 00:00:52,027:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB10BE8970>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB5838F9A0>)
2025-08-28 00:00:52,027:INFO:Checking exceptions
2025-08-28 00:00:52,027:INFO:Preloading libraries
2025-08-28 00:00:52,027:INFO:Set up data.
2025-08-28 00:00:52,030:INFO:Set up index.
2025-08-28 00:00:58,079:INFO:Initializing predict_model()
2025-08-28 00:00:58,079:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57471660>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB10BD9CF0>)
2025-08-28 00:00:58,079:INFO:Checking exceptions
2025-08-28 00:00:58,079:INFO:Preloading libraries
2025-08-28 00:00:58,080:INFO:Set up data.
2025-08-28 00:00:58,083:INFO:Set up index.
2025-08-28 00:01:02,939:INFO:Initializing predict_model()
2025-08-28 00:01:02,939:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB574712D0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB57027AC0>)
2025-08-28 00:01:02,939:INFO:Checking exceptions
2025-08-28 00:01:02,939:INFO:Preloading libraries
2025-08-28 00:01:02,940:INFO:Set up data.
2025-08-28 00:01:02,942:INFO:Set up index.
2025-08-28 00:01:04,705:INFO:Initializing predict_model()
2025-08-28 00:01:04,705:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57472980>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB10BDA680>)
2025-08-28 00:01:04,705:INFO:Checking exceptions
2025-08-28 00:01:04,705:INFO:Preloading libraries
2025-08-28 00:01:04,706:INFO:Set up data.
2025-08-28 00:01:04,708:INFO:Set up index.
2025-08-28 00:01:09,757:INFO:Initializing predict_model()
2025-08-28 00:01:09,757:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57471510>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB573E1AB0>)
2025-08-28 00:01:09,758:INFO:Checking exceptions
2025-08-28 00:01:09,758:INFO:Preloading libraries
2025-08-28 00:01:09,758:INFO:Set up data.
2025-08-28 00:01:09,760:INFO:Set up index.
2025-08-28 00:01:14,070:INFO:Initializing predict_model()
2025-08-28 00:01:14,070:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB10C52F50>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB573E13F0>)
2025-08-28 00:01:14,071:INFO:Checking exceptions
2025-08-28 00:01:14,071:INFO:Preloading libraries
2025-08-28 00:01:14,071:INFO:Set up data.
2025-08-28 00:01:14,073:INFO:Set up index.
2025-08-28 00:01:14,321:INFO:Initializing predict_model()
2025-08-28 00:01:14,321:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5859F130>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB10BD85E0>)
2025-08-28 00:01:14,321:INFO:Checking exceptions
2025-08-28 00:01:14,321:INFO:Preloading libraries
2025-08-28 00:01:14,322:INFO:Set up data.
2025-08-28 00:01:14,323:INFO:Set up index.
2025-08-28 00:01:14,447:INFO:Initializing predict_model()
2025-08-28 00:01:14,447:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB109FD3C0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB58453F40>)
2025-08-28 00:01:14,447:INFO:Checking exceptions
2025-08-28 00:01:14,447:INFO:Preloading libraries
2025-08-28 00:01:14,447:INFO:Set up data.
2025-08-28 00:01:14,449:INFO:Set up index.
2025-08-28 00:03:57,517:INFO:Initializing predict_model()
2025-08-28 00:03:57,517:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB573C9120>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB573E2710>)
2025-08-28 00:03:57,518:INFO:Checking exceptions
2025-08-28 00:03:57,518:INFO:Preloading libraries
2025-08-28 00:03:57,518:INFO:Set up data.
2025-08-28 00:03:57,521:INFO:Set up index.
2025-08-28 00:04:00,575:INFO:Initializing predict_model()
2025-08-28 00:04:00,575:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5843D600>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB58453F40>)
2025-08-28 00:04:00,575:INFO:Checking exceptions
2025-08-28 00:04:00,575:INFO:Preloading libraries
2025-08-28 00:04:00,576:INFO:Set up data.
2025-08-28 00:04:00,579:INFO:Set up index.
2025-08-28 00:04:01,852:INFO:Initializing predict_model()
2025-08-28 00:04:01,852:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57094040>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB10BD9FC0>)
2025-08-28 00:04:01,853:INFO:Checking exceptions
2025-08-28 00:04:01,853:INFO:Preloading libraries
2025-08-28 00:04:01,853:INFO:Set up data.
2025-08-28 00:04:01,856:INFO:Set up index.
2025-08-28 00:05:31,635:INFO:Initializing predict_model()
2025-08-28 00:05:31,635:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57705F90>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB573E1E10>)
2025-08-28 00:05:31,635:INFO:Checking exceptions
2025-08-28 00:05:31,635:INFO:Preloading libraries
2025-08-28 00:05:31,636:INFO:Set up data.
2025-08-28 00:05:31,638:INFO:Set up index.
2025-08-28 00:05:33,521:INFO:Initializing predict_model()
2025-08-28 00:05:33,521:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846A4A0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB573E1F30>)
2025-08-28 00:05:33,521:INFO:Checking exceptions
2025-08-28 00:05:33,521:INFO:Preloading libraries
2025-08-28 00:05:33,521:INFO:Set up data.
2025-08-28 00:05:33,524:INFO:Set up index.
2025-08-28 00:05:34,111:INFO:Initializing predict_model()
2025-08-28 00:05:34,111:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57A4EBF0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB10BD97E0>)
2025-08-28 00:05:34,111:INFO:Checking exceptions
2025-08-28 00:05:34,111:INFO:Preloading libraries
2025-08-28 00:05:34,111:INFO:Set up data.
2025-08-28 00:05:34,114:INFO:Set up index.
2025-08-28 00:05:34,544:INFO:Initializing predict_model()
2025-08-28 00:05:34,545:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846A620>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB10BDA680>)
2025-08-28 00:05:34,545:INFO:Checking exceptions
2025-08-28 00:05:34,545:INFO:Preloading libraries
2025-08-28 00:05:34,545:INFO:Set up data.
2025-08-28 00:05:34,549:INFO:Set up index.
2025-08-28 00:05:35,191:INFO:Initializing predict_model()
2025-08-28 00:05:35,192:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB58469F30>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB5754F9A0>)
2025-08-28 00:05:35,192:INFO:Checking exceptions
2025-08-28 00:05:35,192:INFO:Preloading libraries
2025-08-28 00:05:35,192:INFO:Set up data.
2025-08-28 00:05:35,195:INFO:Set up index.
2025-08-28 00:05:36,540:INFO:Initializing predict_model()
2025-08-28 00:05:36,541:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB109FD450>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB57E17400>)
2025-08-28 00:05:36,541:INFO:Checking exceptions
2025-08-28 00:05:36,541:INFO:Preloading libraries
2025-08-28 00:05:36,541:INFO:Set up data.
2025-08-28 00:05:36,544:INFO:Set up index.
2025-08-28 00:05:37,052:INFO:Initializing predict_model()
2025-08-28 00:05:37,052:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB58469E40>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB10BD9D80>)
2025-08-28 00:05:37,052:INFO:Checking exceptions
2025-08-28 00:05:37,052:INFO:Preloading libraries
2025-08-28 00:05:37,053:INFO:Set up data.
2025-08-28 00:05:37,057:INFO:Set up index.
2025-08-28 00:06:08,141:INFO:Initializing predict_model()
2025-08-28 00:06:08,141:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57706440>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB574FE170>)
2025-08-28 00:06:08,142:INFO:Checking exceptions
2025-08-28 00:06:08,142:INFO:Preloading libraries
2025-08-28 00:06:08,142:INFO:Set up data.
2025-08-28 00:06:08,144:INFO:Set up index.
2025-08-28 00:06:09,276:INFO:Initializing predict_model()
2025-08-28 00:06:09,277:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB10BE90C0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB5754F9A0>)
2025-08-28 00:06:09,277:INFO:Checking exceptions
2025-08-28 00:06:09,277:INFO:Preloading libraries
2025-08-28 00:06:09,277:INFO:Set up data.
2025-08-28 00:06:09,279:INFO:Set up index.
2025-08-28 00:06:10,024:INFO:Initializing predict_model()
2025-08-28 00:06:10,024:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB109FD420>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB57436F80>)
2025-08-28 00:06:10,024:INFO:Checking exceptions
2025-08-28 00:06:10,024:INFO:Preloading libraries
2025-08-28 00:06:10,024:INFO:Set up data.
2025-08-28 00:06:10,027:INFO:Set up index.
2025-08-28 00:06:10,594:INFO:Initializing predict_model()
2025-08-28 00:06:10,594:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5843D600>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB57436DD0>)
2025-08-28 00:06:10,594:INFO:Checking exceptions
2025-08-28 00:06:10,594:INFO:Preloading libraries
2025-08-28 00:06:10,595:INFO:Set up data.
2025-08-28 00:06:10,599:INFO:Set up index.
2025-08-28 00:06:11,172:INFO:Initializing predict_model()
2025-08-28 00:06:11,173:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57471240>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB5754FAC0>)
2025-08-28 00:06:11,173:INFO:Checking exceptions
2025-08-28 00:06:11,173:INFO:Preloading libraries
2025-08-28 00:06:11,173:INFO:Set up data.
2025-08-28 00:06:11,175:INFO:Set up index.
2025-08-28 00:06:11,652:INFO:Initializing predict_model()
2025-08-28 00:06:11,652:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB10BE9510>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB10C64C10>)
2025-08-28 00:06:11,652:INFO:Checking exceptions
2025-08-28 00:06:11,652:INFO:Preloading libraries
2025-08-28 00:06:11,653:INFO:Set up data.
2025-08-28 00:06:11,655:INFO:Set up index.
2025-08-28 00:06:12,291:INFO:Initializing predict_model()
2025-08-28 00:06:12,291:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57472D10>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB57715000>)
2025-08-28 00:06:12,291:INFO:Checking exceptions
2025-08-28 00:06:12,291:INFO:Preloading libraries
2025-08-28 00:06:12,292:INFO:Set up data.
2025-08-28 00:06:12,295:INFO:Set up index.
2025-08-28 00:06:12,766:INFO:Initializing predict_model()
2025-08-28 00:06:12,766:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB573F9AE0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB574FCC10>)
2025-08-28 00:06:12,766:INFO:Checking exceptions
2025-08-28 00:06:12,767:INFO:Preloading libraries
2025-08-28 00:06:12,767:INFO:Set up data.
2025-08-28 00:06:12,769:INFO:Set up index.
2025-08-28 00:07:56,804:INFO:Initializing predict_model()
2025-08-28 00:07:56,804:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5859D900>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB10BD9D80>)
2025-08-28 00:07:56,804:INFO:Checking exceptions
2025-08-28 00:07:56,804:INFO:Preloading libraries
2025-08-28 00:07:56,805:INFO:Set up data.
2025-08-28 00:07:56,808:INFO:Set up index.
2025-08-28 00:07:56,977:INFO:Initializing predict_model()
2025-08-28 00:07:56,977:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB10C8BC10>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB57E17400>)
2025-08-28 00:07:56,978:INFO:Checking exceptions
2025-08-28 00:07:56,978:INFO:Preloading libraries
2025-08-28 00:07:56,978:INFO:Set up data.
2025-08-28 00:07:56,981:INFO:Set up index.
2025-08-28 00:12:32,952:INFO:Initializing predict_model()
2025-08-28 00:12:32,953:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB574715D0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB5754FAC0>)
2025-08-28 00:12:32,953:INFO:Checking exceptions
2025-08-28 00:12:32,953:INFO:Preloading libraries
2025-08-28 00:12:32,953:INFO:Set up data.
2025-08-28 00:12:32,956:INFO:Set up index.
2025-08-28 00:12:35,904:INFO:Initializing predict_model()
2025-08-28 00:12:35,904:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846A6B0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB10BD9C60>)
2025-08-28 00:12:35,904:INFO:Checking exceptions
2025-08-28 00:12:35,904:INFO:Preloading libraries
2025-08-28 00:12:35,904:INFO:Set up data.
2025-08-28 00:12:35,907:INFO:Set up index.
2025-08-28 00:12:36,029:INFO:Initializing predict_model()
2025-08-28 00:12:36,029:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB10BE8400>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB584532E0>)
2025-08-28 00:12:36,030:INFO:Checking exceptions
2025-08-28 00:12:36,030:INFO:Preloading libraries
2025-08-28 00:12:36,030:INFO:Set up data.
2025-08-28 00:12:36,032:INFO:Set up index.
2025-08-28 00:55:03,214:INFO:Initializing predict_model()
2025-08-28 00:55:03,214:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB10C52F50>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB5838F9A0>)
2025-08-28 00:55:03,214:INFO:Checking exceptions
2025-08-28 00:55:03,215:INFO:Preloading libraries
2025-08-28 00:55:03,215:INFO:Set up data.
2025-08-28 00:55:03,217:INFO:Set up index.
2025-08-28 00:55:03,791:INFO:Initializing predict_model()
2025-08-28 00:55:03,791:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57471E40>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB573E1CF0>)
2025-08-28 00:55:03,792:INFO:Checking exceptions
2025-08-28 00:55:03,792:INFO:Preloading libraries
2025-08-28 00:55:03,792:INFO:Set up data.
2025-08-28 00:55:03,795:INFO:Set up index.
2025-08-28 00:55:17,652:INFO:Initializing predict_model()
2025-08-28 00:55:17,652:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846B0D0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB5838F9A0>)
2025-08-28 00:55:17,652:INFO:Checking exceptions
2025-08-28 00:55:17,652:INFO:Preloading libraries
2025-08-28 00:55:17,653:INFO:Set up data.
2025-08-28 00:55:17,654:INFO:Set up index.
2025-08-28 00:55:18,610:INFO:Initializing predict_model()
2025-08-28 00:55:18,610:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB577063E0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB573E1B40>)
2025-08-28 00:55:18,610:INFO:Checking exceptions
2025-08-28 00:55:18,610:INFO:Preloading libraries
2025-08-28 00:55:18,610:INFO:Set up data.
2025-08-28 00:55:18,612:INFO:Set up index.
2025-08-28 00:55:18,744:INFO:Initializing predict_model()
2025-08-28 00:55:18,744:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846BB20>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB10BD8550>)
2025-08-28 00:55:18,744:INFO:Checking exceptions
2025-08-28 00:55:18,744:INFO:Preloading libraries
2025-08-28 00:55:18,745:INFO:Set up data.
2025-08-28 00:55:18,748:INFO:Set up index.
2025-08-28 00:55:28,001:INFO:Initializing predict_model()
2025-08-28 00:55:28,001:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB584693F0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB573E1FC0>)
2025-08-28 00:55:28,002:INFO:Checking exceptions
2025-08-28 00:55:28,002:INFO:Preloading libraries
2025-08-28 00:55:28,002:INFO:Set up data.
2025-08-28 00:55:28,004:INFO:Set up index.
2025-08-28 00:55:28,952:INFO:Initializing predict_model()
2025-08-28 00:55:28,952:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846A3E0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB573E1E10>)
2025-08-28 00:55:28,952:INFO:Checking exceptions
2025-08-28 00:55:28,953:INFO:Preloading libraries
2025-08-28 00:55:28,953:INFO:Set up data.
2025-08-28 00:55:28,955:INFO:Set up index.
2025-08-28 00:55:29,084:INFO:Initializing predict_model()
2025-08-28 00:55:29,085:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57521030>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB57436A70>)
2025-08-28 00:55:29,085:INFO:Checking exceptions
2025-08-28 00:55:29,085:INFO:Preloading libraries
2025-08-28 00:55:29,085:INFO:Set up data.
2025-08-28 00:55:29,087:INFO:Set up index.
2025-08-28 00:56:32,493:INFO:Initializing predict_model()
2025-08-28 00:56:32,493:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846A470>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB5754F910>)
2025-08-28 00:56:32,493:INFO:Checking exceptions
2025-08-28 00:56:32,493:INFO:Preloading libraries
2025-08-28 00:56:32,494:INFO:Set up data.
2025-08-28 00:56:32,497:INFO:Set up index.
2025-08-28 00:56:33,485:INFO:Initializing predict_model()
2025-08-28 00:56:33,486:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846BC40>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB573E1B40>)
2025-08-28 00:56:33,486:INFO:Checking exceptions
2025-08-28 00:56:33,486:INFO:Preloading libraries
2025-08-28 00:56:33,486:INFO:Set up data.
2025-08-28 00:56:33,489:INFO:Set up index.
2025-08-28 00:56:36,272:INFO:Initializing predict_model()
2025-08-28 00:56:36,272:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57E10FA0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB57436DD0>)
2025-08-28 00:56:36,272:INFO:Checking exceptions
2025-08-28 00:56:36,272:INFO:Preloading libraries
2025-08-28 00:56:36,272:INFO:Set up data.
2025-08-28 00:56:36,274:INFO:Set up index.
2025-08-28 00:58:21,497:INFO:Initializing predict_model()
2025-08-28 00:58:21,497:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57471E10>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB573E2A70>)
2025-08-28 00:58:21,497:INFO:Checking exceptions
2025-08-28 00:58:21,497:INFO:Preloading libraries
2025-08-28 00:58:21,498:INFO:Set up data.
2025-08-28 00:58:21,502:INFO:Set up index.
2025-08-28 00:58:40,863:INFO:Initializing predict_model()
2025-08-28 00:58:40,863:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846BE80>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB10BD9B40>)
2025-08-28 00:58:40,864:INFO:Checking exceptions
2025-08-28 00:58:40,864:INFO:Preloading libraries
2025-08-28 00:58:40,864:INFO:Set up data.
2025-08-28 00:58:40,868:INFO:Set up index.
2025-08-28 01:02:30,984:INFO:Initializing predict_model()
2025-08-28 01:02:30,984:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846A530>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB5754F910>)
2025-08-28 01:02:30,984:INFO:Checking exceptions
2025-08-28 01:02:30,984:INFO:Preloading libraries
2025-08-28 01:02:30,984:INFO:Set up data.
2025-08-28 01:02:30,989:INFO:Set up index.
2025-08-28 01:02:36,173:INFO:Initializing predict_model()
2025-08-28 01:02:36,173:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846B340>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB573E1CF0>)
2025-08-28 01:02:36,173:INFO:Checking exceptions
2025-08-28 01:02:36,174:INFO:Preloading libraries
2025-08-28 01:02:36,174:INFO:Set up data.
2025-08-28 01:02:36,176:INFO:Set up index.
2025-08-28 01:02:36,304:INFO:Initializing predict_model()
2025-08-28 01:02:36,304:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57521030>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB574FCC10>)
2025-08-28 01:02:36,304:INFO:Checking exceptions
2025-08-28 01:02:36,304:INFO:Preloading libraries
2025-08-28 01:02:36,305:INFO:Set up data.
2025-08-28 01:02:36,307:INFO:Set up index.
2025-08-28 01:02:42,753:INFO:Initializing predict_model()
2025-08-28 01:02:42,753:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB58469630>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB573E1D80>)
2025-08-28 01:02:42,753:INFO:Checking exceptions
2025-08-28 01:02:42,753:INFO:Preloading libraries
2025-08-28 01:02:42,753:INFO:Set up data.
2025-08-28 01:02:42,756:INFO:Set up index.
2025-08-28 01:03:13,254:INFO:Initializing predict_model()
2025-08-28 01:03:13,254:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB10BE91E0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB10BD9BD0>)
2025-08-28 01:03:13,254:INFO:Checking exceptions
2025-08-28 01:03:13,254:INFO:Preloading libraries
2025-08-28 01:03:13,255:INFO:Set up data.
2025-08-28 01:03:13,258:INFO:Set up index.
2025-08-28 01:03:16,288:INFO:Initializing predict_model()
2025-08-28 01:03:16,288:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB5846B0D0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB10BDA680>)
2025-08-28 01:03:16,288:INFO:Checking exceptions
2025-08-28 01:03:16,288:INFO:Preloading libraries
2025-08-28 01:03:16,289:INFO:Set up data.
2025-08-28 01:03:16,291:INFO:Set up index.
2025-08-28 01:03:16,420:INFO:Initializing predict_model()
2025-08-28 01:03:16,420:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB109FD4B0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB10BD9C60>)
2025-08-28 01:03:16,420:INFO:Checking exceptions
2025-08-28 01:03:16,420:INFO:Preloading libraries
2025-08-28 01:03:16,420:INFO:Set up data.
2025-08-28 01:03:16,423:INFO:Set up index.
2025-08-28 01:03:20,638:INFO:Initializing predict_model()
2025-08-28 01:03:20,639:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB3133A4A0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB5754F880>)
2025-08-28 01:03:20,639:INFO:Checking exceptions
2025-08-28 01:03:20,639:INFO:Preloading libraries
2025-08-28 01:03:20,639:INFO:Set up data.
2025-08-28 01:03:20,641:INFO:Set up index.
2025-08-28 01:03:20,901:INFO:Initializing predict_model()
2025-08-28 01:03:20,902:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB584D67A0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB573E1F30>)
2025-08-28 01:03:20,902:INFO:Checking exceptions
2025-08-28 01:03:20,902:INFO:Preloading libraries
2025-08-28 01:03:20,902:INFO:Set up data.
2025-08-28 01:03:20,904:INFO:Set up index.
2025-08-28 01:03:21,031:INFO:Initializing predict_model()
2025-08-28 01:03:21,031:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB109FD420>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB10BD85E0>)
2025-08-28 01:03:21,031:INFO:Checking exceptions
2025-08-28 01:03:21,031:INFO:Preloading libraries
2025-08-28 01:03:21,032:INFO:Set up data.
2025-08-28 01:03:21,033:INFO:Set up index.
2025-08-28 01:03:24,053:INFO:Initializing predict_model()
2025-08-28 01:03:24,054:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57472D40>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB573E13F0>)
2025-08-28 01:03:24,054:INFO:Checking exceptions
2025-08-28 01:03:24,054:INFO:Preloading libraries
2025-08-28 01:03:24,054:INFO:Set up data.
2025-08-28 01:03:24,057:INFO:Set up index.
2025-08-28 01:03:24,317:INFO:Initializing predict_model()
2025-08-28 01:03:24,317:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001EB57521D20>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x000001EB10BD9BD0>)
2025-08-28 01:03:24,317:INFO:Checking exceptions
2025-08-28 01:03:24,317:INFO:Preloading libraries
2025-08-28 01:03:24,317:INFO:Set up data.
2025-08-28 01:03:24,320:INFO:Set up index.
2025-08-28 01:22:10,768:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-28 01:22:10,768:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-28 01:22:10,768:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-28 01:22:10,768:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-28 01:22:12,090:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\mlflow\protos\service_pb2.py:11: UserWarning: google.protobuf.service module is deprecated. RPC implementations should provide code generator plugins which generate code specific to the RPC implementation. service.py will be removed in Jan 2025
  from google.protobuf import service as _service

2025-08-28 01:22:16,136:INFO:Initializing load_model()
2025-08-28 01:22:16,137:INFO:load_model(model_name=models/wheat_seeds_best, platform=None, authentication=None, verbose=True)
2025-08-28 01:29:50,534:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-28 01:29:50,534:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-28 01:29:50,534:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-28 01:29:50,534:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2025-08-28 01:29:51,657:WARNING:C:\Users\javie\anaconda3\envs\mlops\lib\site-packages\mlflow\protos\service_pb2.py:11: UserWarning: google.protobuf.service module is deprecated. RPC implementations should provide code generator plugins which generate code specific to the RPC implementation. service.py will be removed in Jan 2025
  from google.protobuf import service as _service

2025-08-28 01:36:32,006:INFO:Initializing predict_model()
2025-08-28 01:36:32,007:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000019C5924BCA0>, estimator=['models/wheat_seeds_best'], probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x0000019C5911D1B0>)
2025-08-28 01:36:32,007:INFO:Checking exceptions
2025-08-28 01:36:32,007:INFO:Preloading libraries
2025-08-28 01:37:15,734:INFO:Initializing load_model()
2025-08-28 01:37:15,734:INFO:load_model(model_name=models/wheat_seeds_best, platform=None, authentication=None, verbose=True)
2025-08-28 01:37:52,181:INFO:Initializing predict_model()
2025-08-28 01:37:52,182:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000019C590E2260>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x0000019C5911D900>)
2025-08-28 01:37:52,182:INFO:Checking exceptions
2025-08-28 01:37:52,182:INFO:Preloading libraries
2025-08-28 01:37:52,183:INFO:Set up data.
2025-08-28 01:37:52,187:INFO:Set up index.
2025-08-28 01:37:54,211:INFO:Initializing predict_model()
2025-08-28 01:37:54,211:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000019C59ABF520>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x0000019C5A097D00>)
2025-08-28 01:37:54,211:INFO:Checking exceptions
2025-08-28 01:37:54,212:INFO:Preloading libraries
2025-08-28 01:37:54,212:INFO:Set up data.
2025-08-28 01:37:54,217:INFO:Set up index.
2025-08-28 01:46:00,908:INFO:Initializing load_model()
2025-08-28 01:46:00,908:INFO:load_model(model_name=models/wheat_seeds_best, platform=None, authentication=None, verbose=True)
2025-08-28 01:46:02,975:INFO:Initializing predict_model()
2025-08-28 01:46:02,975:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000019C58F37C70>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x0000019C590865F0>)
2025-08-28 01:46:02,976:INFO:Checking exceptions
2025-08-28 01:46:02,976:INFO:Preloading libraries
2025-08-28 01:46:02,976:INFO:Set up data.
2025-08-28 01:46:02,979:INFO:Set up index.
2025-08-28 01:54:19,172:INFO:Initializing predict_model()
2025-08-28 01:54:19,172:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000019C59341570>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x0000019C590F3F40>)
2025-08-28 01:54:19,173:INFO:Checking exceptions
2025-08-28 01:54:19,173:INFO:Preloading libraries
2025-08-28 01:54:19,173:INFO:Set up data.
2025-08-28 01:54:19,178:INFO:Set up index.
2025-08-28 01:54:26,651:INFO:Initializing predict_model()
2025-08-28 01:54:26,651:INFO:predict_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x0000019C593419C0>, estimator=Pipeline(memory=Memory(location=None),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(include=['Compactness', 'Length', 'Width',
                                             'AsymmetryCoeff', 'Groove'],
                                    transformer=SimpleImputer())),
                ('categorical_imputer',
                 TransformerWrapper(include=[],
                                    transformer=SimpleImputer(strategy='most_frequent'))),
                ('normalize', TransformerWrapper(transformer=StandardScaler())),
                ('actual_estimator', LinearDiscriminantAnalysis())]), probability_threshold=None, encoded_labels=False, raw_score=True, round=4, verbose=True, ml_usecase=None, preprocess=True, encode_labels=<function _SupervisedExperiment.predict_model.<locals>.encode_labels at 0x0000019C5643F640>)
2025-08-28 01:54:26,651:INFO:Checking exceptions
2025-08-28 01:54:26,651:INFO:Preloading libraries
2025-08-28 01:54:26,652:INFO:Set up data.
2025-08-28 01:54:26,655:INFO:Set up index.
